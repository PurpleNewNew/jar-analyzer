{
  "name": "jar-analyzer-workflow-with-redis",
  "nodes": [
    {
      "parameters": {},
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [
        0,
        0
      ],
      "id": "389d6683-84ad-46c4-9b49-afda4a133f92",
      "name": "Start Workflow"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-globals.globalConstants",
      "typeVersion": 1,
      "position": [
        200,
        0
      ],
      "id": "05a64e41-2189-4f16-bfdf-9bb2db628016",
      "name": "Global Constants",
      "credentials": {
        "globalConstantsApi": {
          "id": "IH7D2VRyHX4WOTgN",
          "name": "Global Constants account"
        }
      }
    },
    {
      "parameters": {
        "url": "={{ $('Global Constants').first().json.constants['jar-analyzer-api'] }}api/get_jars_list",
        "options": {
          "headers": {
            "Token": "={{ $('Global Constants').first().json.constants['jar-analyzer-api-token'] || '' }}"
          }
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        400,
        0
      ],
      "id": "ad620021-38b9-4d0a-84e6-d7655715ef1a",
      "name": "Get Jars List"
    },
    {
      "parameters": {
        "jsCode": "// Compute a stable projectKey (sha1) from jar list for Redis cache namespacing.\n// Input: /api/get_jars_list response (JSON array of jar paths).\nconst crypto = require('crypto');\n\nlet jars = [];\nfor (const it of $input.all()) {\n  const j = it.json;\n  if (Array.isArray(j)) jars.push(...j);\n  else if (Array.isArray(j?.jars)) jars.push(...j.jars);\n  else if (Array.isArray(j?.data)) jars.push(...j.data);\n}\n\njars = jars\n  .filter(x => typeof x === 'string')\n  .map(s => s.trim())\n  .filter(Boolean);\n\nconst jarsOriginal = jars.slice();\nconst jarsSorted = jars.slice().sort();\nconst payload = jarsSorted.join('\\n');\n\n// Strategy version: bump this string whenever you change workflow logic to invalidate old cache\nconst strategyVersion = '5lines-v1';\n\n// Default TTL: 7 days\nconst cacheTtlSeconds = 7 * 24 * 60 * 60;\n\nconst projectKey = crypto.createHash('sha1').update(payload).digest('hex');\n\nreturn [{\n  json: {\n    jars: jarsSorted,\n    jarsOriginal,\n    jarsSorted,\n    jarCount: jarsOriginal.length,\n    projectKey,\n    strategyVersion,\n    cacheTtlSeconds\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        600,
        0
      ],
      "id": "bcd68895-2a29-4b13-8c4d-82ccafc88d99",
      "name": "Compute Project Key"
    },
    {
      "parameters": {
        "jsCode": "// Initialize scan config for 5-line audit workflow (Redis version).\nconst jars = Array.isArray($json.jars) ? $json.jars : [];\nconst jarCount = typeof $json.jarCount === 'number' ? $json.jarCount : jars.length;\n\n// Prefer original jar ordering (if available) for gadgetDir heuristic\nconst jarsForGadget = Array.isArray($json.jarsOriginal) && $json.jarsOriginal.length\n  ? $json.jarsOriginal\n  : jars;\n\n// Heuristic: derive a default gadgetDir from the first jar path\nlet gadgetDir = '';\nif (jarsForGadget.length > 0) {\n  const first = jarsForGadget[0];\n  const idx = Math.max(first.lastIndexOf('/'), first.lastIndexOf('\\'));\n  if (idx > 0) gadgetDir = first.slice(0, idx);\n}\n\nconst scanConfig = {\n  enableDfsTaint: false,\n\n  // Line switches\n  enableGraphLite: true,\n  enableVulRules: true,\n  enableScaLeak: true,\n  scope: 'app',\n  excludeNoise: true,\n  limits: {\n    auditFast: { callLimit: 14, mappingSampleLimit: 120, resourceSearchLimit: 80, strSearchPerKeyword: 20, maxCodeConfirm: 6 },\n    graphLite: { callLimit: 16, sinkPerTypeLimit: 20, maxDepth: 4, maxChains: 60 },\n    vulRules: { callLimit: 10, levels: ['high','medium'], groupBy: 'rule', perRuleLimit: 15, totalLimit: 160 },\n    scaLeak: { callLimit: 10, enableSca: true, enableLeak: true, enableGadget: false, gadgetDir: gadgetDir, leakLimit: 120 },\n    stage0: {\n      maxFindings: 120,\n      perLineLimit: 60\n    },\n    configUsage: {\n      callLimit: 10,\n      resourceSearchLimit: 60,\n      strSearchPerKey: 20,\n      maxCodeConfirm: 4,\n      maxKeys: 12\n    },\n    dfsTaint: { callLimit: 28, sinkNames: ['Runtime.exec(String)','ProcessBuilder.start','InitialContext.lookup','URL.openConnection'], depth: 10, maxLimit: 80, maxPaths: 80, timeoutMs: 90000, onlyFromWeb: true, resultLimit: 120, compact: true }\n  }\n};\n\nfunction stableStringify(obj) {\n  if (obj === null || obj === undefined) return 'null';\n  if (Array.isArray(obj)) return '[' + obj.map(stableStringify).join(',') + ']';\n  if (typeof obj === 'object') {\n    const keys = Object.keys(obj).sort();\n    return '{' + keys.map(k => JSON.stringify(k) + ':' + stableStringify(obj[k])).join(',') + '}';\n  }\n  return JSON.stringify(obj);\n}\n\nfunction hash32(str) {\n  let h = 2166136261;\n  for (let i = 0; i < str.length; i++) {\n    h ^= str.charCodeAt(i);\n    h += (h << 1) + (h << 4) + (h << 7) + (h << 8) + (h << 24);\n  }\n  return (h >>> 0).toString(16);\n}\n\nconst scanConfigHash = hash32(stableStringify(scanConfig));\n\nreturn [{\n  json: {\n    ...$json,\n    jars,\n    jarCount,\n    scanConfig,\n    scanConfigHash,\n    rulesHash: $json?.rulesHash || $json?.rulesVersion || undefined,\n    filterHash: $json?.filterHash || $json?.filtersVersion || undefined,\n    strategyVersion: $json?.strategyVersion || '5lines-v2'\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        800,
        0
      ],
      "id": "b5c56f72-40f4-4fa6-9f68-c27a61e9d614",
      "name": "Init Scan Config"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "glm-4.6",
          "mode": "list",
          "cachedResultName": "GLM-4.6"
        },
        "options": {
          "thinking": true
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatAnthropic",
      "typeVersion": 1.3,
      "position": [
        800,
        -500
      ],
      "id": "8b9afc54-1e6b-4ee1-9391-6d920975dfa1",
      "name": "LLM",
      "credentials": {
        "anthropicApi": {
          "id": "TaNxIU4TnOE9TUHI",
          "name": "Anthropic account"
        }
      }
    },
    {
      "parameters": {
        "endpointUrl": "={{ $('Global Constants').first().json.constants['jar-analyzer-mcp-audit-fast'] }}sse",
        "serverTransport": "sse",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.mcpClientTool",
      "typeVersion": 1.2,
      "position": [
        1000,
        -500
      ],
      "id": "a5d3f21a-16a1-40eb-b1f1-d6043b377f0a",
      "name": "MCP audit-fast"
    },
    {
      "parameters": {
        "endpointUrl": "={{ $('Global Constants').first().json.constants['jar-analyzer-mcp-graph-lite'] }}sse",
        "serverTransport": "sse",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.mcpClientTool",
      "typeVersion": 1.2,
      "position": [
        1000,
        -430
      ],
      "id": "4ee9b1df-fc56-4092-b21e-f383e92a8831",
      "name": "MCP graph-lite"
    },
    {
      "parameters": {
        "endpointUrl": "={{ $('Global Constants').first().json.constants['jar-analyzer-mcp-vul-rules'] }}sse",
        "serverTransport": "sse",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.mcpClientTool",
      "typeVersion": 1.2,
      "position": [
        1000,
        -360
      ],
      "id": "66cac3b1-072f-47f8-8774-5f566ae6577a",
      "name": "MCP vul-rules"
    },
    {
      "parameters": {
        "endpointUrl": "={{ $('Global Constants').first().json.constants['jar-analyzer-mcp-sca-leak'] }}sse",
        "serverTransport": "sse",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.mcpClientTool",
      "typeVersion": 1.2,
      "position": [
        1000,
        -290
      ],
      "id": "3f391298-ece1-4ea8-b91b-e1adbd8a9e9b",
      "name": "MCP sca-leak"
    },
    {
      "parameters": {
        "endpointUrl": "={{ $('Global Constants').first().json.constants['jar-analyzer-mcp-dfs-taint'] }}sse",
        "serverTransport": "sse",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.mcpClientTool",
      "typeVersion": 1.2,
      "position": [
        1000,
        -220
      ],
      "id": "531c6f73-ec94-480f-b682-52b9180d1263",
      "name": "MCP dfs-taint"
    },
    {
      "parameters": {
        "endpointUrl": "={{ $('Global Constants').first().json.constants['report-service-mcp'] }}sse",
        "serverTransport": "sse",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.mcpClientTool",
      "typeVersion": 1.2,
      "position": [
        1000,
        520
      ],
      "id": "8796d45e-44ac-4443-825c-3a83f5e96dac",
      "name": "MCP report"
    },
    {
      "parameters": {
        "jsCode": "// Build Redis cacheKey for line: audit-fast\nconst strategyVersion = $json.strategyVersion || '5lines-v2';\nconst projectKey = $json.projectKey || 'unknown';\nconst scanConfigHash = $json.scanConfigHash || 'cfg0';\nconst rulesHash = $json.rulesHash || 'rules0';\nconst filterHash = $json.filterHash || 'filter0';\nconst cacheKey = `ja:5lines:${strategyVersion}:${projectKey}:${scanConfigHash}:${rulesHash}:${filterHash}:audit-fast`;\n\nreturn [{\n  json: {\n    ...$json,\n    line: \"audit-fast\",\n    cacheKey\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1000,
        -300
      ],
      "id": "bc1a016b-b077-4197-8209-b7e5d43d4063",
      "name": "Build Cache Key audit-fast"
    },
    {
      "parameters": {
        "operation": "get",
        "key": "={{ $json.cacheKey }}",
        "options": {}
      },
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [
        1200,
        -300
      ],
      "id": "136c5919-74a0-430e-a642-270f2008a4e9",
      "name": "Redis GET audit-fast",
      "continueOnFail": true,
      "retryOnFail": true,
      "maxTries": 2,
      "waitBetweenTries": 500,
      "credentials": {
        "redis": {
          "id": "REPLACE_WITH_YOUR_REDIS_CREDENTIAL_ID",
          "name": "Redis account"
        }
      },
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "jsCode": "// Interpret Redis GET output and decide cacheHit.\n// Expected Redis node shape for GET: { value: <string|null> }.\n// We only inspect known value fields to avoid accidentally treating other context strings as cache values.\nconst j = $json || {};\n\nfunction getRedisValue(obj) {\n  if (!obj || typeof obj !== 'object') return null;\n\n  if (typeof obj.value === 'string' || obj.value === null) return obj.value;\n  if (typeof obj.data === 'string' || obj.data === null) return obj.data;\n  if (typeof obj.result === 'string' || obj.result === null) return obj.result;\n\n  // Some variants may nest under \"redis\"\n  if (obj.redis && typeof obj.redis === 'object') {\n    const r = obj.redis;\n    if (typeof r.value === 'string' || r.value === null) return r.value;\n    if (typeof r.data === 'string' || r.data === null) return r.data;\n    if (typeof r.result === 'string' || r.result === null) return r.result;\n  }\n\n  return null;\n}\n\nconst rawVal = getRedisValue(j);\nconst rawStr = (typeof rawVal === 'string') ? rawVal : '';\n\nlet cacheHit = false;\nlet cacheParseOk = false;\nlet cachedRecord = null;\nlet cacheError = null;\n\nif (rawStr && rawStr.trim().length > 0) {\n  try {\n    cachedRecord = JSON.parse(rawStr);\n    cacheParseOk = true;\n    cacheHit = true;\n  } catch (e) {\n    cacheError = `cache_json_parse_error: ${String(e)}`;\n  }\n}\n\nreturn {\n  json: {\n    ...j,\n    cacheHit,\n    cacheParseOk,\n    cacheError,\n    cachedRecord,\n    cacheValuePreview: rawStr.length > 500 ? rawStr.slice(0, 500) + '...(truncated)' : rawStr\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1400,
        -300
      ],
      "id": "8e533845-654c-4c94-a1d8-45c1c2b0ef90",
      "name": "Interpret Cache audit-fast"
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.cacheHit }}",
              "operation": "isTrue"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        1600,
        -300
      ],
      "id": "819f316b-2ad6-4bec-97a0-4da5f686daa6",
      "name": "If Cache Hit audit-fast"
    },
    {
      "parameters": {
        "jsCode": "// Use cachedRecord for audit-fast\nconst j = $json || {};\nconst rec = j.cachedRecord;\nlet findings = [];\nif (rec) {\n  if (Array.isArray(rec.findings)) findings = rec.findings;\n  else if (Array.isArray(rec)) findings = rec;\n  else if (typeof rec === 'object') findings = [rec];\n}\nreturn [{\n  json: {\n    ...j,\n    line: \"audit-fast\",\n    cacheHit: true,\n    cacheMeta: rec && rec.meta ? rec.meta : undefined,\n    cacheSavedAt: rec && rec.savedAt ? rec.savedAt : undefined,\n    parseOk: j.cacheParseOk === true,\n    parseError: j.cacheError || \"\",\n    findings\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1800,
        -360
      ],
      "id": "f073a115-b4a0-454f-8014-0c9cf7d6f4f6",
      "name": "Use Cached audit-fast"
    },
    {
      "parameters": {
        "jsCode": "const ctx = $json || {};\nconst className = String(ctx.className || \"unknown\");\nconst entryTypes = Array.isArray(ctx.entryTypes) ? ctx.entryTypes : (ctx.entryType ? [ctx.entryType] : []);\nconst entryType = ctx.entryType || (entryTypes[0] || \"\");\nconst classInfo = ctx.classInfo || {};\nconst methods = Array.isArray(ctx.methods) ? ctx.methods : [];\nconst mappings = Array.isArray(ctx.mappings) ? ctx.mappings : [];\n\nconst lim = ($node[\"Init Scan Config\"]?.json?.scanConfig?.limits?.auditFast) || {};\nconst methodListLimit = lim.methodListLimit || 120;\nconst mappingLimit = lim.mappingSampleLimit || 120;\nconst maxCodeConfirm = lim.maxCodeConfirm || 6;\nconst resourceSearchLimit = lim.resourceSearchLimit || 80;\nconst strSearchPerKeyword = lim.strSearchPerKeyword || 20;\n\nconst methodsSample = methods.slice(0, methodListLimit);\nconst mappingsSample = mappings.slice(0, mappingLimit);\n\nlet callLimit = methodsSample.length * 3;\ncallLimit = callLimit > 50 ? 50 : callLimit;\ncallLimit = callLimit < 6 ? 6 : callLimit;\n\nconst stage0 = ctx.stage0Context || $node[\"Stage 0 Aggregate Context\"]?.json?.stage0Context || {};\n\nconst configUsage = $json.configUsageContext || $node[\"Config Usage Context\"]?.json?.configUsageContext || $node[\"Global Context Hub\"]?.json?.configUsageContext || {};\nconst hintConfigKeys = Array.isArray(configUsage.keys) ? configUsage.keys : [];\nconst hintConfigMethods = Array.isArray(configUsage.methods) ? configUsage.methods : [];\nconst hintConfigResources = Array.isArray(configUsage.resources) ? configUsage.resources : [];\nconst hintRuleNames = Array.isArray(stage0.ruleNames) ? stage0.ruleNames : [];\nconst hintRuleMethods = Array.isArray(stage0.ruleMethods) ? stage0.ruleMethods : [];\nconst hintLeakTypes = Array.isArray(stage0.leakTypeNames) ? stage0.leakTypeNames : [];\nconst hintLeakValues = Array.isArray(stage0.leakValues) ? stage0.leakValues : [];\nconst hintSuspectTypes = Array.isArray(stage0.suspectTypes) ? stage0.suspectTypes : [];\nconst hintSinkNames = Array.isArray(stage0.sinkNames) ? stage0.sinkNames : [];\n\nconst hintLines = [];\nif (hintConfigMethods.length) hintLines.push(`Config methods(${hintConfigMethods.length}): ${hintConfigMethods.slice(0, 10).join(', ')}`);\nif (hintConfigKeys.length) hintLines.push(`Config keys: ${hintConfigKeys.slice(0, 10).join(', ')}`);\nif (hintRuleNames.length) hintLines.push(`????(${hintRuleNames.length}): ${hintRuleNames.slice(0, 12).join(', ')}`);\nif (hintRuleMethods.length) hintLines.push(`??????(${hintRuleMethods.length}): ${hintRuleMethods.slice(0, 12).join(', ')}`);\nif (hintSuspectTypes.length) hintLines.push(`????: ${hintSuspectTypes.join(', ')}`);\nif (hintLeakTypes.length) hintLines.push(`????: ${hintLeakTypes.join(', ')}`);\nif (hintLeakValues.length) hintLines.push(`????(??): ${hintLeakValues.slice(0, 8).join(', ')}`);\nif (hintSinkNames.length) hintLines.push(`Sink ??: ${hintSinkNames.slice(0, 8).join(', ')}`);\nconst hintBlock = hintLines.length ? `\n[Global Hints]\n${hintLines.join('\n')}\n` : '';\n\nconst vulnTypes = [\n  \"deserialize\",\n  \"file_path_traversal\",\n  \"redirect\",\n  \"ssrf\",\n  \"sql_injection\",\n  \"template_injection\",\n  \"arbitrary_file_download\",\n  \"arbitrary_file_upload\",\n  \"code_injection\",\n  \"arbitrary_spring_bean_call\",\n  \"command_execution\"\n];\n\nconst chatInput = `\n????? **audit-fast**????????????????? API???????\n??????????/??????? get_all_* / get_methods_by_class / get_spring_mappings ?????????\n???????????????????????????????? MCP ???????\n\n[Entry]\nclassName: ${className}\nentryType: ${entryType}\nentryTypes: ${JSON.stringify(entryTypes)}\nclassInfo: ${JSON.stringify({\n  isInterface: classInfo.isInterfaceInt ?? classInfo.isInterface ?? null,\n  superClassName: classInfo.superClassName || classInfo.superClass || \"\"\n})}\n\n[mappings] (sample, max ${mappingLimit}):\n${JSON.stringify(mappingsSample, null, 2)}\n\n[methods] (sample, max ${methodListLimit}):\n${JSON.stringify(methodsSample, null, 2)}\n${hintBlock}\n????? MCP ??????????????\n- search_resources(query, limit=${resourceSearchLimit})\n- get_methods_by_str_batch(items=[{str,limit}...], limit=${strSearchPerKeyword})\n- get_methods_by_anno(anno/match/scope, limit)\n- get_call_edges(class, method, desc, mode)\n- get_code_cfr(class, method, desc)??? ${maxCodeConfirm} ??\n- get_callers / get_callers_by_sink???????????\n\n???\n- ? Global Hints ???????????/????????\n- ruleMethods ???????????????????????\n- ???????????/??????????/?????\n\n????????${JSON.stringify(vulnTypes)}\n\n?????\n- ??? JSON ????????????? []\n- ?? finding ???? line/type/severity/confidence/score/reason/trace\n- trace ??????????????\n- reason ???????????mapping/method/?????\n`;\n\nreturn [{ json: { ...ctx, line: \"audit-fast\", callLimit, chatInput } }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1800,
        -240
      ],
      "id": "eec319ce-5465-43d7-a899-576b22b2fcc4",
      "name": "Build Prompt audit-fast"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.chatInput }}",
        "options": {
          "systemMessage": "你正在执行 audit-fast 主线。入口/方法/映射已经由上游 API 提供，可直接作为事实证据使用。\n不要重复调用入口枚举类工具（get_all_* / get_methods_by_class / get_spring_mappings）。\n如需补充证据，只能使用允许的 MCP 工具（search_resources / get_methods_by_str_batch / get_methods_by_anno / get_call_edges / get_code_cfr / get_callers / get_callers_by_sink）。\n你是资深 Java 安全审计工程师，目标是做自动化安全审计（静态分析）。\n必须遵守：\n1) 只能使用当前可用的 MCP 工具获取事实证据；禁止凭空猜测。\n2) 严格控制输出规模：优先使用批量/limit/compact/totalLimit 参数。\n3) 只输出 JSON 数组（不要输出解释、不要 Markdown、不要代码块围栏）。没有发现则输出 []。\n4) findings 数组元素必须包含字段：\n   - line (string)\n   - type (string)\n   - severity (\"high\"|\"medium\"|\"low\")\n   - confidence (\"high\"|\"medium\"|\"low\")\n   - score (1-10 整数)\n   - reason (string, 简洁说明命中原因与证据点)\n   - trace (array, 每项包含 {\"class\",\"method\",\"desc\"}；desc 可为空字符串)\n可以附加 evidence/metadata 等字段，但不要输出大段源码全文。",
          "maxIterations": "={{ $json.callLimit }}"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2.2,
      "position": [
        2000,
        -240
      ],
      "id": "bdea7ddf-afe9-4311-9f4d-2deaf2b78c6c",
      "name": "Agent audit-fast",
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "jsCode": "// Parse AI Agent output into {line, findings[]} while preserving context fields (e.g., cacheKey/projectKey).\nconst ctx = $json || {};\nconst line = ctx.line || (ctx.context && ctx.context.line) || \"unknown\";\n\nfunction extractText(v) {\n  if (v === null || v === undefined) return \"\";\n  if (typeof v === \"string\") return v;\n  try { return JSON.stringify(v); } catch (e) { return String(v); }\n}\n\nlet raw = ctx.output ?? ctx.text ?? ctx.data ?? ctx;\nlet s = extractText(raw).trim();\n\n// Strip markdown fences if present\nconst fence = s.match(/```json\\s*([\\s\\S]*?)```/i);\nif (fence && fence[1]) s = fence[1].trim();\n\nlet findings = [];\nlet parseOk = false;\nlet parseError = \"\";\n\nif (!s) {\n  parseError = \"empty_response\";\n} else {\n  try {\n    const obj = JSON.parse(s);\n    if (Array.isArray(obj)) {\n      findings = obj;\n      parseOk = true;\n    } else if (obj && typeof obj === \"object\") {\n      if (Array.isArray(obj.findings)) {\n        findings = obj.findings;\n        parseOk = true;\n      } else if (Array.isArray(obj.data)) {\n        findings = obj.data;\n        parseOk = true;\n      } else {\n        parseError = \"json_object_without_findings_array\";\n      }\n    } else {\n      parseError = \"json_not_array\";\n    }\n  } catch (e) {\n    parseError = e.message || String(e);\n  }\n}\n\nreturn [{\n  json: {\n    ...ctx,\n    line,\n    parseOk,\n    parseError,\n    findings: Array.isArray(findings) ? findings : []\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2200,
        -240
      ],
      "id": "8826e6c2-5f90-4628-b963-59a38be0a07c",
      "name": "Parse audit-fast"
    },
    {
      "parameters": {
        "jsCode": "// Prepare cacheValue JSON for audit-fast\nconst j = $json || {};\nif (j.parseOk !== true) {\n  return [];\n}\nconst cacheValue = JSON.stringify({\n  line: \"audit-fast\",\n  savedAt: new Date().toISOString(),\n  meta: {\n    projectKey: j.projectKey,\n    strategyVersion: j.strategyVersion,\n    scanConfigHash: j.scanConfigHash,\n    rulesHash: j.rulesHash,\n    filterHash: j.filterHash\n  },\n  findings: Array.isArray(j.findings) ? j.findings : []\n});\nreturn [{\n  json: {\n    ...j,\n    cacheValue\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2400,
        -240
      ],
      "id": "5b5bc274-d507-4717-bf49-88ba8d242277",
      "name": "Prepare Cache Value audit-fast"
    },
    {
      "parameters": {
        "operation": "set",
        "key": "={{ $json.cacheKey }}",
        "value": "={{ $json.cacheValue }}",
        "keyType": "string",
        "expire": true,
        "ttl": "={{ $json.cacheTtlSeconds }}"
      },
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [
        2600,
        -240
      ],
      "id": "83ea7823-c71c-4084-9e76-e64dff40aaf1",
      "name": "Redis SET audit-fast",
      "continueOnFail": true,
      "retryOnFail": true,
      "maxTries": 2,
      "waitBetweenTries": 500,
      "credentials": {
        "redis": {
          "id": "REPLACE_WITH_YOUR_REDIS_CREDENTIAL_ID",
          "name": "Redis account"
        }
      },
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "jsCode": "// Build Redis cacheKey for line: graph-lite\nconst strategyVersion = $json.strategyVersion || '5lines-v2';\nconst projectKey = $json.projectKey || 'unknown';\nconst scanConfigHash = $json.scanConfigHash || 'cfg0';\nconst rulesHash = $json.rulesHash || 'rules0';\nconst filterHash = $json.filterHash || 'filter0';\nconst cacheKey = `ja:5lines:${strategyVersion}:${projectKey}:${scanConfigHash}:${rulesHash}:${filterHash}:graph-lite`;\n\nreturn [{\n  json: {\n    ...$json,\n    line: \"graph-lite\",\n    cacheKey\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1000,
        -120
      ],
      "id": "05eabef1-ee4e-4c43-a01e-6743ab9f0b38",
      "name": "Build Cache Key graph-lite"
    },
    {
      "parameters": {
        "operation": "get",
        "key": "={{ $json.cacheKey }}",
        "options": {}
      },
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [
        1200,
        -120
      ],
      "id": "25b40a6d-fb4b-4c0a-b2e9-04372d2f077d",
      "name": "Redis GET graph-lite",
      "continueOnFail": true,
      "retryOnFail": true,
      "maxTries": 2,
      "waitBetweenTries": 500,
      "credentials": {
        "redis": {
          "id": "REPLACE_WITH_YOUR_REDIS_CREDENTIAL_ID",
          "name": "Redis account"
        }
      },
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "jsCode": "// Interpret Redis GET output and decide cacheHit.\n// Expected Redis node shape for GET: { value: <string|null> }.\n// We only inspect known value fields to avoid accidentally treating other context strings as cache values.\nconst j = $json || {};\n\nfunction getRedisValue(obj) {\n  if (!obj || typeof obj !== 'object') return null;\n\n  if (typeof obj.value === 'string' || obj.value === null) return obj.value;\n  if (typeof obj.data === 'string' || obj.data === null) return obj.data;\n  if (typeof obj.result === 'string' || obj.result === null) return obj.result;\n\n  // Some variants may nest under \"redis\"\n  if (obj.redis && typeof obj.redis === 'object') {\n    const r = obj.redis;\n    if (typeof r.value === 'string' || r.value === null) return r.value;\n    if (typeof r.data === 'string' || r.data === null) return r.data;\n    if (typeof r.result === 'string' || r.result === null) return r.result;\n  }\n\n  return null;\n}\n\nconst rawVal = getRedisValue(j);\nconst rawStr = (typeof rawVal === 'string') ? rawVal : '';\n\nlet cacheHit = false;\nlet cacheParseOk = false;\nlet cachedRecord = null;\nlet cacheError = null;\n\nif (rawStr && rawStr.trim().length > 0) {\n  try {\n    cachedRecord = JSON.parse(rawStr);\n    cacheParseOk = true;\n    cacheHit = true;\n  } catch (e) {\n    cacheError = `cache_json_parse_error: ${String(e)}`;\n  }\n}\n\nreturn {\n  json: {\n    ...j,\n    cacheHit,\n    cacheParseOk,\n    cacheError,\n    cachedRecord,\n    cacheValuePreview: rawStr.length > 500 ? rawStr.slice(0, 500) + '...(truncated)' : rawStr\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1400,
        -120
      ],
      "id": "006d23ea-f281-4cba-94b0-e93cab8bbe4c",
      "name": "Interpret Cache graph-lite"
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.cacheHit }}",
              "operation": "isTrue"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        1600,
        -120
      ],
      "id": "8b44d5c1-61ae-4fd3-b2fc-8491f212498d",
      "name": "If Cache Hit graph-lite"
    },
    {
      "parameters": {
        "jsCode": "// Use cachedRecord for graph-lite\nconst j = $json || {};\nconst rec = j.cachedRecord;\nlet findings = [];\nif (rec) {\n  if (Array.isArray(rec.findings)) findings = rec.findings;\n  else if (Array.isArray(rec)) findings = rec;\n  else if (typeof rec === 'object') findings = [rec];\n}\nreturn [{\n  json: {\n    ...j,\n    line: \"graph-lite\",\n    cacheHit: true,\n    cacheMeta: rec && rec.meta ? rec.meta : undefined,\n    cacheSavedAt: rec && rec.savedAt ? rec.savedAt : undefined,\n    parseOk: j.cacheParseOk === true,\n    parseError: j.cacheError || \"\",\n    findings\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1800,
        -180
      ],
      "id": "2293fdbc-74bd-45c0-a3fc-6a9eda189825",
      "name": "Use Cached graph-lite"
    },
    {
      "parameters": {
        "jsCode": "const cfg = $json.scanConfig || {};\nconst lim = cfg.limits && cfg.limits.graphLite ? cfg.limits.graphLite : {};\nconst callLimit = lim.callLimit || 16;\n\nconst ctx = $json.stageAContext || {};\nconst hintEntryClasses = Array.isArray(ctx.entryClasses) ? ctx.entryClasses : [];\nconst hintRuleMethods = Array.isArray(ctx.ruleMethods) ? ctx.ruleMethods : [];\nconst hintRuleNames = Array.isArray(ctx.ruleNames) ? ctx.ruleNames : [];\nconst hintSinkNames = Array.isArray(ctx.sinkNames) ? ctx.sinkNames : [];\nconst hintSuspectTypes = Array.isArray(ctx.suspectTypes) ? ctx.suspectTypes : [];\nconst configUsage = $json.configUsageContext || $node[\"Config Usage Context\"]?.json?.configUsageContext || $node[\"Global Context Hub\"]?.json?.configUsageContext || {};\nconst hintConfigMethods = Array.isArray(configUsage.methods) ? configUsage.methods : [];\nconst hintConfigKeys = Array.isArray(configUsage.keys) ? configUsage.keys : [];\n\n\nconst baseSinkNames = [\n  \"Runtime.exec(String)\",\n  \"ProcessBuilder.start\",\n  \"ScriptEngine.eval\",\n  \"InitialContext.lookup\",\n  \"Context.lookup\",\n  \"DirContext.search\",\n  \"LdapContext.search\",\n  \"Statement.executeQuery\",\n  \"Statement.executeUpdate\",\n  \"Connection.prepareStatement\",\n  \"ObjectInputStream.readObject\",\n  \"XMLDecoder.readObject\",\n  \"Yaml.load\",\n  \"JSON.parseObject\",\n  \"ObjectMapper.readValue\",\n  \"HessianInput.readObject\",\n  \"XStream.fromXML\",\n  \"URL.openConnection\",\n  \"HttpURLConnection.connect\",\n  \"FileInputStream.new\",\n  \"FileOutputStream.new\",\n  \"RandomAccessFile.new\",\n  \"File.delete\"\n];\n\nconst sinkNames = Array.from(new Set([...(hintSinkNames || []), ...baseSinkNames]));\n\nconst sinkPerTypeLimit = lim.sinkPerTypeLimit || 20;\nconst maxDepth = lim.maxDepth || 4;\nconst maxChains = lim.maxChains || 60;\n\nconst hintLines = [];\nif (hintConfigMethods.length) hintLines.push(`Config methods(${hintConfigMethods.length}): ${hintConfigMethods.slice(0, 10).join(', ')}`);\nif (hintConfigKeys.length) hintLines.push(`Config keys: ${hintConfigKeys.slice(0, 10).join(', ')}`);\nif (hintEntryClasses.length) hintLines.push(`?????(${hintEntryClasses.length}): ${hintEntryClasses.slice(0, 12).join(', ')}`);\nif (hintRuleMethods.length) hintLines.push(`????????(${hintRuleMethods.length}): ${hintRuleMethods.slice(0, 12).join(', ')}`);\nif (hintRuleNames.length) hintLines.push(`????(${hintRuleNames.length}): ${hintRuleNames.slice(0, 12).join(', ')}`);\nif (hintSuspectTypes.length) hintLines.push(`????: ${hintSuspectTypes.join(', ')}`);\nconst hintBlock = hintLines.length ? `\n[Hints]\n${hintLines.join('\n')}\n` : '';\n\nconst chatInput = `\n????? **graph-lite**???????/???????????\n?????? Sink ????????????????????????????? JSON findings?\n${hintBlock}\n????????????????\n1) ??? sinkName ???? get_callers_by_sink(sinkName, limit=${sinkPerTypeLimit})?\n   ${JSON.stringify(sinkNames)}\n2) ??? sink ???????MethodResult??\n   - ???????????? ${maxDepth} ??\n     ?? get_callers(class, method, desc) ??????\n   - ?????? 2~3 ???????? caller?????? java/javax/sun?????? Controller/Service/Action/Servlet/Handler?\n   - ??? Hints ?????/??/???????????????\n   - ?????????????? doGet/doPost/service?????? Controller/Servlet???????\n3) ??????? 1 ? finding??? ${maxChains} ???\n   - type??? sinkName ?????command_exec/sql_injection/jndi_injection/deserialization/ssrf/file_io ??\n   - confidence???????????? medium/high??? low/medium\n   - trace?????????????????sink????????????? trace ? callers ? + sink ???\n???\n- ?? graph-lite???????????????????????? reason ???????????? dfs/taint ????\n- ????? []\n`;\nreturn [{ json: { ...$json, line: \"graph-lite\", callLimit, chatInput } }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1800,
        -60
      ],
      "id": "880b25c6-6463-4bc0-9e5c-3890b140076e",
      "name": "Build Prompt graph-lite"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.chatInput }}",
        "options": {
          "systemMessage": "你是资深 Java 安全审计工程师，目标是做自动化安全审计（静态分析）。\n必须遵守：\n1) 只能使用当前可用的 MCP 工具获取事实证据；禁止凭空猜测。\n2) 严格控制输出规模：优先使用批量/limit/compact/totalLimit 参数。\n3) 只输出 JSON 数组（不要输出解释、不要 Markdown、不要代码块围栏）。没有发现则输出 []。\n4) findings 数组元素必须包含字段：\n   - line (string)\n   - type (string)\n   - severity (\"high\"|\"medium\"|\"low\")\n   - confidence (\"high\"|\"medium\"|\"low\")\n   - score (1-10 整数)\n   - reason (string, 简洁说明命中原因与证据点)\n   - trace (array, 每项包含 {\"class\",\"method\",\"desc\"}；desc 可为空字符串)\n可以附加 evidence/metadata 等字段，但不要输出大段源码全文。",
          "maxIterations": "={{ $json.callLimit }}"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2.2,
      "position": [
        2000,
        -60
      ],
      "id": "77ebd930-8d7f-4fb8-93a0-e3a993dd4dbd",
      "name": "Agent graph-lite",
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "jsCode": "// Parse AI Agent output into {line, findings[]} while preserving context fields (e.g., cacheKey/projectKey).\nconst ctx = $json || {};\nconst line = ctx.line || (ctx.context && ctx.context.line) || \"unknown\";\n\nfunction extractText(v) {\n  if (v === null || v === undefined) return \"\";\n  if (typeof v === \"string\") return v;\n  try { return JSON.stringify(v); } catch (e) { return String(v); }\n}\n\nlet raw = ctx.output ?? ctx.text ?? ctx.data ?? ctx;\nlet s = extractText(raw).trim();\n\n// Strip markdown fences if present\nconst fence = s.match(/```json\\s*([\\s\\S]*?)```/i);\nif (fence && fence[1]) s = fence[1].trim();\n\nlet findings = [];\nlet parseOk = false;\nlet parseError = \"\";\n\nif (!s) {\n  parseError = \"empty_response\";\n} else {\n  try {\n    const obj = JSON.parse(s);\n    if (Array.isArray(obj)) {\n      findings = obj;\n      parseOk = true;\n    } else if (obj && typeof obj === \"object\") {\n      if (Array.isArray(obj.findings)) {\n        findings = obj.findings;\n        parseOk = true;\n      } else if (Array.isArray(obj.data)) {\n        findings = obj.data;\n        parseOk = true;\n      } else {\n        parseError = \"json_object_without_findings_array\";\n      }\n    } else {\n      parseError = \"json_not_array\";\n    }\n  } catch (e) {\n    parseError = e.message || String(e);\n  }\n}\n\nreturn [{\n  json: {\n    ...ctx,\n    line,\n    parseOk,\n    parseError,\n    findings: Array.isArray(findings) ? findings : []\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2200,
        -60
      ],
      "id": "c9027fb0-8ec9-4beb-b42e-36ba6239006e",
      "name": "Parse graph-lite"
    },
    {
      "parameters": {
        "jsCode": "// Prepare cacheValue JSON for graph-lite\nconst j = $json || {};\nif (j.parseOk !== true) {\n  return [];\n}\nconst cacheValue = JSON.stringify({\n  line: \"graph-lite\",\n  savedAt: new Date().toISOString(),\n  meta: {\n    projectKey: j.projectKey,\n    strategyVersion: j.strategyVersion,\n    scanConfigHash: j.scanConfigHash,\n    rulesHash: j.rulesHash,\n    filterHash: j.filterHash\n  },\n  findings: Array.isArray(j.findings) ? j.findings : []\n});\nreturn [{\n  json: {\n    ...j,\n    cacheValue\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2400,
        -60
      ],
      "id": "df1ecd67-c356-43aa-9734-87f2bc2a450b",
      "name": "Prepare Cache Value graph-lite"
    },
    {
      "parameters": {
        "operation": "set",
        "key": "={{ $json.cacheKey }}",
        "value": "={{ $json.cacheValue }}",
        "keyType": "string",
        "expire": true,
        "ttl": "={{ $json.cacheTtlSeconds }}"
      },
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [
        2600,
        -60
      ],
      "id": "bcfe8f59-c81b-4afb-898b-5d5910d98157",
      "name": "Redis SET graph-lite",
      "continueOnFail": true,
      "retryOnFail": true,
      "maxTries": 2,
      "waitBetweenTries": 500,
      "credentials": {
        "redis": {
          "id": "REPLACE_WITH_YOUR_REDIS_CREDENTIAL_ID",
          "name": "Redis account"
        }
      },
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "jsCode": "// Build Redis cacheKey for line: vul-rules\nconst strategyVersion = $json.strategyVersion || '5lines-v2';\nconst projectKey = $json.projectKey || 'unknown';\nconst scanConfigHash = $json.scanConfigHash || 'cfg0';\nconst rulesHash = $json.rulesHash || 'rules0';\nconst filterHash = $json.filterHash || 'filter0';\nconst cacheKey = `ja:5lines:${strategyVersion}:${projectKey}:${scanConfigHash}:${rulesHash}:${filterHash}:vul-rules`;\n\nreturn [{\n  json: {\n    ...$json,\n    line: \"vul-rules\",\n    cacheKey\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1000,
        60
      ],
      "id": "3b40da87-e30c-46aa-a31a-c7d5a6307a93",
      "name": "Build Cache Key vul-rules"
    },
    {
      "parameters": {
        "operation": "get",
        "key": "={{ $json.cacheKey }}",
        "options": {}
      },
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [
        1200,
        60
      ],
      "id": "a8c2934a-06b1-4ecc-9ab5-081f2d360b17",
      "name": "Redis GET vul-rules",
      "continueOnFail": true,
      "retryOnFail": true,
      "maxTries": 2,
      "waitBetweenTries": 500,
      "credentials": {
        "redis": {
          "id": "REPLACE_WITH_YOUR_REDIS_CREDENTIAL_ID",
          "name": "Redis account"
        }
      },
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "jsCode": "// Interpret Redis GET output and decide cacheHit.\n// Expected Redis node shape for GET: { value: <string|null> }.\n// We only inspect known value fields to avoid accidentally treating other context strings as cache values.\nconst j = $json || {};\n\nfunction getRedisValue(obj) {\n  if (!obj || typeof obj !== 'object') return null;\n\n  if (typeof obj.value === 'string' || obj.value === null) return obj.value;\n  if (typeof obj.data === 'string' || obj.data === null) return obj.data;\n  if (typeof obj.result === 'string' || obj.result === null) return obj.result;\n\n  // Some variants may nest under \"redis\"\n  if (obj.redis && typeof obj.redis === 'object') {\n    const r = obj.redis;\n    if (typeof r.value === 'string' || r.value === null) return r.value;\n    if (typeof r.data === 'string' || r.data === null) return r.data;\n    if (typeof r.result === 'string' || r.result === null) return r.result;\n  }\n\n  return null;\n}\n\nconst rawVal = getRedisValue(j);\nconst rawStr = (typeof rawVal === 'string') ? rawVal : '';\n\nlet cacheHit = false;\nlet cacheParseOk = false;\nlet cachedRecord = null;\nlet cacheError = null;\n\nif (rawStr && rawStr.trim().length > 0) {\n  try {\n    cachedRecord = JSON.parse(rawStr);\n    cacheParseOk = true;\n    cacheHit = true;\n  } catch (e) {\n    cacheError = `cache_json_parse_error: ${String(e)}`;\n  }\n}\n\nreturn {\n  json: {\n    ...j,\n    cacheHit,\n    cacheParseOk,\n    cacheError,\n    cachedRecord,\n    cacheValuePreview: rawStr.length > 500 ? rawStr.slice(0, 500) + '...(truncated)' : rawStr\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1400,
        60
      ],
      "id": "7628c487-1bda-4a5d-84ff-3416b768d846",
      "name": "Interpret Cache vul-rules"
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.cacheHit }}",
              "operation": "isTrue"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        1600,
        60
      ],
      "id": "4afeb0a7-1a5b-4208-ae10-970e48a433a2",
      "name": "If Cache Hit vul-rules"
    },
    {
      "parameters": {
        "jsCode": "// Use cachedRecord for vul-rules\nconst j = $json || {};\nconst rec = j.cachedRecord;\nlet findings = [];\nif (rec) {\n  if (Array.isArray(rec.findings)) findings = rec.findings;\n  else if (Array.isArray(rec)) findings = rec;\n  else if (typeof rec === 'object') findings = [rec];\n}\nreturn [{\n  json: {\n    ...j,\n    line: \"vul-rules\",\n    cacheHit: true,\n    cacheMeta: rec && rec.meta ? rec.meta : undefined,\n    cacheSavedAt: rec && rec.savedAt ? rec.savedAt : undefined,\n    parseOk: j.cacheParseOk === true,\n    parseError: j.cacheError || \"\",\n    findings\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1800,
        0
      ],
      "id": "8c96911a-c479-47ff-80d7-2dcfcd08c300",
      "name": "Use Cached vul-rules"
    },
    {
      "parameters": {
        "jsCode": "const cfg = $json.scanConfig || {};\nconst lim = cfg.limits && cfg.limits.vulRules ? cfg.limits.vulRules : {};\nconst callLimit = lim.callLimit || 10;\n\nconst levels = Array.isArray(lim.levels) && lim.levels.length ? lim.levels : [\"high\"];\nconst perRuleLimit = lim.perRuleLimit || 15;\nconst totalLimit = lim.totalLimit || 160;\nconst groupBy = lim.groupBy || \"rule\";\n\nconst chatInput = `\n你正在执行 **vul-rules**（规则线）。\n目标：使用 rules/vulnerability.yaml 规则在全局搜索调用点，并将命中转换为 JSON findings。\n\n执行步骤（按 levels 顺序，务必控量）：\n1) 可选：get_vul_rules 获取规则概览（用于了解可用 rule 名称）\n2) 对每个 level ∈ ${JSON.stringify(levels)}：\n   - 调用 vul_search(level=level, groupBy=\"rule\", totalLimit=${totalLimit}, limit=${perRuleLimit})\n   - 对命中 count>0 的规则（优先 high 命中多的）：\n     再调用 vul_search(name=ruleName, level=level, groupBy=\"method\", totalLimit=${totalLimit}, limit=${perRuleLimit})\n3) 将每个 MethodResult 命中点输出为 finding：\n   - line=\"vul-rules\"\n   - type：可直接用 \"vul-rule::<ruleName>\"（也可以映射为更具体类型）\n   - severity：来自 rule 的 level（high/medium/low）\n   - confidence：medium（规则命中是调用点，仍需结合入口/参数判定可利用性）\n   - trace：至少包含命中方法（class/method/desc）；若结果中带 actualPath/restfulType/jarName，可放入 evidence\n注意：\n- 不要输出重复项（同一 class#method#desc + 同一 ruleName 只输出一次）\n- 无发现输出 []\n`;\nreturn [{ json: { ...$json, line: \"vul-rules\", callLimit, chatInput } }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1800,
        120
      ],
      "id": "ebbc6790-f85c-40b9-bc2c-8789aad8ad09",
      "name": "Build Prompt vul-rules"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.chatInput }}",
        "options": {
          "systemMessage": "你是资深 Java 安全审计工程师，目标是做自动化安全审计（静态分析）。\n必须遵守：\n1) 只能使用当前可用的 MCP 工具获取事实证据；禁止凭空猜测。\n2) 严格控制输出规模：优先使用批量/limit/compact/totalLimit 参数。\n3) 只输出 JSON 数组（不要输出解释、不要 Markdown、不要代码块围栏）。没有发现则输出 []。\n4) findings 数组元素必须包含字段：\n   - line (string)\n   - type (string)\n   - severity (\"high\"|\"medium\"|\"low\")\n   - confidence (\"high\"|\"medium\"|\"low\")\n   - score (1-10 整数)\n   - reason (string, 简洁说明命中原因与证据点)\n   - trace (array, 每项包含 {\"class\",\"method\",\"desc\"}；desc 可为空字符串)\n可以附加 evidence/metadata 等字段，但不要输出大段源码全文。",
          "maxIterations": "={{ $json.callLimit }}"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2.2,
      "position": [
        2000,
        120
      ],
      "id": "e83b2cd9-bb7e-4986-8ca8-8bdf609d6b6c",
      "name": "Agent vul-rules",
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "jsCode": "// Parse AI Agent output into {line, findings[]} while preserving context fields (e.g., cacheKey/projectKey).\nconst ctx = $json || {};\nconst line = ctx.line || (ctx.context && ctx.context.line) || \"unknown\";\n\nfunction extractText(v) {\n  if (v === null || v === undefined) return \"\";\n  if (typeof v === \"string\") return v;\n  try { return JSON.stringify(v); } catch (e) { return String(v); }\n}\n\nlet raw = ctx.output ?? ctx.text ?? ctx.data ?? ctx;\nlet s = extractText(raw).trim();\n\n// Strip markdown fences if present\nconst fence = s.match(/```json\\s*([\\s\\S]*?)```/i);\nif (fence && fence[1]) s = fence[1].trim();\n\nlet findings = [];\nlet parseOk = false;\nlet parseError = \"\";\n\nif (!s) {\n  parseError = \"empty_response\";\n} else {\n  try {\n    const obj = JSON.parse(s);\n    if (Array.isArray(obj)) {\n      findings = obj;\n      parseOk = true;\n    } else if (obj && typeof obj === \"object\") {\n      if (Array.isArray(obj.findings)) {\n        findings = obj.findings;\n        parseOk = true;\n      } else if (Array.isArray(obj.data)) {\n        findings = obj.data;\n        parseOk = true;\n      } else {\n        parseError = \"json_object_without_findings_array\";\n      }\n    } else {\n      parseError = \"json_not_array\";\n    }\n  } catch (e) {\n    parseError = e.message || String(e);\n  }\n}\n\nreturn [{\n  json: {\n    ...ctx,\n    line,\n    parseOk,\n    parseError,\n    findings: Array.isArray(findings) ? findings : []\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2200,
        120
      ],
      "id": "0a0549c8-2840-4816-988b-3a7915717eed",
      "name": "Parse vul-rules"
    },
    {
      "parameters": {
        "jsCode": "// Prepare cacheValue JSON for vul-rules\nconst j = $json || {};\nif (j.parseOk !== true) {\n  return [];\n}\nconst cacheValue = JSON.stringify({\n  line: \"vul-rules\",\n  savedAt: new Date().toISOString(),\n  meta: {\n    projectKey: j.projectKey,\n    strategyVersion: j.strategyVersion,\n    scanConfigHash: j.scanConfigHash,\n    rulesHash: j.rulesHash,\n    filterHash: j.filterHash\n  },\n  findings: Array.isArray(j.findings) ? j.findings : []\n});\nreturn [{\n  json: {\n    ...j,\n    cacheValue\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2400,
        120
      ],
      "id": "4b10cace-8914-4bd9-b8c0-5a7c8a342954",
      "name": "Prepare Cache Value vul-rules"
    },
    {
      "parameters": {
        "operation": "set",
        "key": "={{ $json.cacheKey }}",
        "value": "={{ $json.cacheValue }}",
        "keyType": "string",
        "expire": true,
        "ttl": "={{ $json.cacheTtlSeconds }}"
      },
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [
        2600,
        120
      ],
      "id": "c4be20da-4824-4af1-b002-d8c49d7491eb",
      "name": "Redis SET vul-rules",
      "continueOnFail": true,
      "retryOnFail": true,
      "maxTries": 2,
      "waitBetweenTries": 500,
      "credentials": {
        "redis": {
          "id": "REPLACE_WITH_YOUR_REDIS_CREDENTIAL_ID",
          "name": "Redis account"
        }
      },
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "jsCode": "// Build Redis cacheKey for line: sca-leak\nconst strategyVersion = $json.strategyVersion || '5lines-v2';\nconst projectKey = $json.projectKey || 'unknown';\nconst scanConfigHash = $json.scanConfigHash || 'cfg0';\nconst rulesHash = $json.rulesHash || 'rules0';\nconst filterHash = $json.filterHash || 'filter0';\nconst cacheKey = `ja:5lines:${strategyVersion}:${projectKey}:${scanConfigHash}:${rulesHash}:${filterHash}:sca-leak`;\n\nreturn [{\n  json: {\n    ...$json,\n    line: \"sca-leak\",\n    cacheKey\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1000,
        240
      ],
      "id": "8d0d62a4-337e-46c1-9b6c-424a77d2b84d",
      "name": "Build Cache Key sca-leak"
    },
    {
      "parameters": {
        "operation": "get",
        "key": "={{ $json.cacheKey }}",
        "options": {}
      },
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [
        1200,
        240
      ],
      "id": "6f2565b2-4ee0-465c-9df4-efcf4035130b",
      "name": "Redis GET sca-leak",
      "continueOnFail": true,
      "retryOnFail": true,
      "maxTries": 2,
      "waitBetweenTries": 500,
      "credentials": {
        "redis": {
          "id": "REPLACE_WITH_YOUR_REDIS_CREDENTIAL_ID",
          "name": "Redis account"
        }
      },
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "jsCode": "// Interpret Redis GET output and decide cacheHit.\n// Expected Redis node shape for GET: { value: <string|null> }.\n// We only inspect known value fields to avoid accidentally treating other context strings as cache values.\nconst j = $json || {};\n\nfunction getRedisValue(obj) {\n  if (!obj || typeof obj !== 'object') return null;\n\n  if (typeof obj.value === 'string' || obj.value === null) return obj.value;\n  if (typeof obj.data === 'string' || obj.data === null) return obj.data;\n  if (typeof obj.result === 'string' || obj.result === null) return obj.result;\n\n  // Some variants may nest under \"redis\"\n  if (obj.redis && typeof obj.redis === 'object') {\n    const r = obj.redis;\n    if (typeof r.value === 'string' || r.value === null) return r.value;\n    if (typeof r.data === 'string' || r.data === null) return r.data;\n    if (typeof r.result === 'string' || r.result === null) return r.result;\n  }\n\n  return null;\n}\n\nconst rawVal = getRedisValue(j);\nconst rawStr = (typeof rawVal === 'string') ? rawVal : '';\n\nlet cacheHit = false;\nlet cacheParseOk = false;\nlet cachedRecord = null;\nlet cacheError = null;\n\nif (rawStr && rawStr.trim().length > 0) {\n  try {\n    cachedRecord = JSON.parse(rawStr);\n    cacheParseOk = true;\n    cacheHit = true;\n  } catch (e) {\n    cacheError = `cache_json_parse_error: ${String(e)}`;\n  }\n}\n\nreturn {\n  json: {\n    ...j,\n    cacheHit,\n    cacheParseOk,\n    cacheError,\n    cachedRecord,\n    cacheValuePreview: rawStr.length > 500 ? rawStr.slice(0, 500) + '...(truncated)' : rawStr\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1400,
        240
      ],
      "id": "78ca9e05-9434-454d-bcb5-455e70bff32c",
      "name": "Interpret Cache sca-leak"
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.cacheHit }}",
              "operation": "isTrue"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        1600,
        240
      ],
      "id": "bc7df292-3f6c-47d4-8ca7-94169104a883",
      "name": "If Cache Hit sca-leak"
    },
    {
      "parameters": {
        "jsCode": "// Use cachedRecord for sca-leak\nconst j = $json || {};\nconst rec = j.cachedRecord;\nlet findings = [];\nif (rec) {\n  if (Array.isArray(rec.findings)) findings = rec.findings;\n  else if (Array.isArray(rec)) findings = rec;\n  else if (typeof rec === 'object') findings = [rec];\n}\nreturn [{\n  json: {\n    ...j,\n    line: \"sca-leak\",\n    cacheHit: true,\n    cacheMeta: rec && rec.meta ? rec.meta : undefined,\n    cacheSavedAt: rec && rec.savedAt ? rec.savedAt : undefined,\n    parseOk: j.cacheParseOk === true,\n    parseError: j.cacheError || \"\",\n    findings\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1800,
        180
      ],
      "id": "dbf29ced-4e76-4a04-9acd-f2719317a1d3",
      "name": "Use Cached sca-leak"
    },
    {
      "parameters": {
        "jsCode": "const cfg = $json.scanConfig || {};\nconst lim = cfg.limits && cfg.limits.scaLeak ? cfg.limits.scaLeak : {};\nconst callLimit = lim.callLimit || 10;\n\nconst enableSca = lim.enableSca !== false;\nconst enableLeak = lim.enableLeak !== false;\nconst enableGadget = lim.enableGadget === true;\nconst gadgetDir = lim.gadgetDir || '';\nconst leakLimit = lim.leakLimit || 120;\n\nconst chatInput = `\n你正在执行 **sca-leak**（依赖/泄露线）。\n目标：执行 SCA 漏洞依赖扫描 + 泄露扫描（可选 gadget 扫描），输出 JSON findings。\n\n执行步骤：\n1) ${enableSca ? \"调用 sca_scan(log4j=1, fastjson=1, shiro=1) 获取依赖漏洞命中（CVE/cvss/jarPath/project/version）。\" : \"跳过 sca_scan（enableSca=false）。\"}\n2) ${enableLeak ? `调用 leak_scan(limit=${leakLimit}, scope=\"${cfg.scope||'app'}\") 获取泄露（typeName/value/className/jarName）。` : \"跳过 leak_scan（enableLeak=false）。\"}\n3) ${enableGadget ? `调用 gadget_scan(dir=\"${gadgetDir}\", native=1, hessian=1, fastjson=1, jdbc=1) 获取 gadget 依赖链命中。` : \"gadget_scan 默认关闭（enableGadget=false 或 gadgetDir 为空）。\"}\n\n输出规范：\n- SCA 命中：type=\"dependency_cve\"，severity 按 cvss（>=9 high, >=7 medium, else low），confidence=high\n- 泄露命中：type=\"secret_leak\"，severity=high，confidence=high（reason 需包含 typeName 与脱敏 value 片段）\n- gadget 命中：type=\"gadget_presence\" 或 \"deserialization_gadget\"，severity=medium/high，confidence=medium/high\n- trace：至少包含 1 个点；对于 SCA 可用 jarPath 作为 trace 的 desc（class/method 可留空但必须给字段）；对于 leak 可用 className 作为 class\n注意：\n- 输出 value 时务必脱敏：只保留前 4 + 后 4（中间用 ***）\n- 无发现输出 []\n`;\nreturn [{ json: { ...$json, line: \"sca-leak\", callLimit, chatInput } }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1800,
        300
      ],
      "id": "6001ad06-f7f1-43c6-a825-16f7291b3fc4",
      "name": "Build Prompt sca-leak"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.chatInput }}",
        "options": {
          "systemMessage": "你是资深 Java 安全审计工程师，目标是做自动化安全审计（静态分析）。\n必须遵守：\n1) 只能使用当前可用的 MCP 工具获取事实证据；禁止凭空猜测。\n2) 严格控制输出规模：优先使用批量/limit/compact/totalLimit 参数。\n3) 只输出 JSON 数组（不要输出解释、不要 Markdown、不要代码块围栏）。没有发现则输出 []。\n4) findings 数组元素必须包含字段：\n   - line (string)\n   - type (string)\n   - severity (\"high\"|\"medium\"|\"low\")\n   - confidence (\"high\"|\"medium\"|\"low\")\n   - score (1-10 整数)\n   - reason (string, 简洁说明命中原因与证据点)\n   - trace (array, 每项包含 {\"class\",\"method\",\"desc\"}；desc 可为空字符串)\n可以附加 evidence/metadata 等字段，但不要输出大段源码全文。",
          "maxIterations": "={{ $json.callLimit }}"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2.2,
      "position": [
        2000,
        300
      ],
      "id": "d7310326-e6a3-43a9-9761-03df097af76c",
      "name": "Agent sca-leak",
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "jsCode": "// Parse AI Agent output into {line, findings[]} while preserving context fields (e.g., cacheKey/projectKey).\nconst ctx = $json || {};\nconst line = ctx.line || (ctx.context && ctx.context.line) || \"unknown\";\n\nfunction extractText(v) {\n  if (v === null || v === undefined) return \"\";\n  if (typeof v === \"string\") return v;\n  try { return JSON.stringify(v); } catch (e) { return String(v); }\n}\n\nlet raw = ctx.output ?? ctx.text ?? ctx.data ?? ctx;\nlet s = extractText(raw).trim();\n\n// Strip markdown fences if present\nconst fence = s.match(/```json\\s*([\\s\\S]*?)```/i);\nif (fence && fence[1]) s = fence[1].trim();\n\nlet findings = [];\nlet parseOk = false;\nlet parseError = \"\";\n\nif (!s) {\n  parseError = \"empty_response\";\n} else {\n  try {\n    const obj = JSON.parse(s);\n    if (Array.isArray(obj)) {\n      findings = obj;\n      parseOk = true;\n    } else if (obj && typeof obj === \"object\") {\n      if (Array.isArray(obj.findings)) {\n        findings = obj.findings;\n        parseOk = true;\n      } else if (Array.isArray(obj.data)) {\n        findings = obj.data;\n        parseOk = true;\n      } else {\n        parseError = \"json_object_without_findings_array\";\n      }\n    } else {\n      parseError = \"json_not_array\";\n    }\n  } catch (e) {\n    parseError = e.message || String(e);\n  }\n}\n\nreturn [{\n  json: {\n    ...ctx,\n    line,\n    parseOk,\n    parseError,\n    findings: Array.isArray(findings) ? findings : []\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2200,
        300
      ],
      "id": "0461215b-edd7-4741-bc2b-1d0b4e58acd0",
      "name": "Parse sca-leak"
    },
    {
      "parameters": {
        "jsCode": "// Prepare cacheValue JSON for sca-leak\nconst j = $json || {};\nif (j.parseOk !== true) {\n  return [];\n}\nconst cacheValue = JSON.stringify({\n  line: \"sca-leak\",\n  savedAt: new Date().toISOString(),\n  meta: {\n    projectKey: j.projectKey,\n    strategyVersion: j.strategyVersion,\n    scanConfigHash: j.scanConfigHash,\n    rulesHash: j.rulesHash,\n    filterHash: j.filterHash\n  },\n  findings: Array.isArray(j.findings) ? j.findings : []\n});\nreturn [{\n  json: {\n    ...j,\n    cacheValue\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2400,
        300
      ],
      "id": "4f1788bd-10e2-4f63-8128-63173efc9b67",
      "name": "Prepare Cache Value sca-leak"
    },
    {
      "parameters": {
        "operation": "set",
        "key": "={{ $json.cacheKey }}",
        "value": "={{ $json.cacheValue }}",
        "keyType": "string",
        "expire": true,
        "ttl": "={{ $json.cacheTtlSeconds }}"
      },
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [
        2600,
        300
      ],
      "id": "3c6bd6d3-e297-4759-8f3b-48651eb34264",
      "name": "Redis SET sca-leak",
      "continueOnFail": true,
      "retryOnFail": true,
      "maxTries": 2,
      "waitBetweenTries": 500,
      "credentials": {
        "redis": {
          "id": "REPLACE_WITH_YOUR_REDIS_CREDENTIAL_ID",
          "name": "Redis account"
        }
      },
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.scanConfig.enableDfsTaint }}",
              "operation": "isTrue"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        1000,
        420
      ],
      "id": "f213b8c5-b800-4219-bf53-75a295fe048e",
      "name": "If Enable dfs-taint"
    },
    {
      "parameters": {
        "jsCode": "// DFS slow line disabled: return empty findings placeholder so merge can proceed.\nreturn [{\n  json: {\n    line: \"dfs-taint\",\n    parseOk: true,\n    parseError: \"disabled\",\n    findings: []\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1200,
        520
      ],
      "id": "572dc3b4-0f6f-43f8-bfeb-d3f29ed8783f",
      "name": "DFS Disabled"
    },
    {
      "parameters": {
        "jsCode": "// Build Redis cacheKey for line: dfs-taint\nconst strategyVersion = $json.strategyVersion || '5lines-v2';\nconst projectKey = $json.projectKey || 'unknown';\nconst scanConfigHash = $json.scanConfigHash || 'cfg0';\nconst rulesHash = $json.rulesHash || 'rules0';\nconst filterHash = $json.filterHash || 'filter0';\nconst cacheKey = `ja:5lines:${strategyVersion}:${projectKey}:${scanConfigHash}:${rulesHash}:${filterHash}:dfs-taint`;\n\nreturn [{\n  json: {\n    ...$json,\n    line: \"dfs-taint\",\n    cacheKey\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1200,
        360
      ],
      "id": "0b99da5d-8537-47b8-b793-7d1df5acdc1c",
      "name": "Build Cache Key dfs-taint"
    },
    {
      "parameters": {
        "operation": "get",
        "key": "={{ $json.cacheKey }}",
        "options": {}
      },
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [
        1400,
        360
      ],
      "id": "322faaa2-0b02-4e91-9bee-b4bfd12b64ec",
      "name": "Redis GET dfs-taint",
      "continueOnFail": true,
      "retryOnFail": true,
      "maxTries": 2,
      "waitBetweenTries": 500,
      "credentials": {
        "redis": {
          "id": "REPLACE_WITH_YOUR_REDIS_CREDENTIAL_ID",
          "name": "Redis account"
        }
      },
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "jsCode": "// Interpret Redis GET output and decide cacheHit.\n// Expected Redis node shape for GET: { value: <string|null> }.\n// We only inspect known value fields to avoid accidentally treating other context strings as cache values.\nconst j = $json || {};\n\nfunction getRedisValue(obj) {\n  if (!obj || typeof obj !== 'object') return null;\n\n  if (typeof obj.value === 'string' || obj.value === null) return obj.value;\n  if (typeof obj.data === 'string' || obj.data === null) return obj.data;\n  if (typeof obj.result === 'string' || obj.result === null) return obj.result;\n\n  // Some variants may nest under \"redis\"\n  if (obj.redis && typeof obj.redis === 'object') {\n    const r = obj.redis;\n    if (typeof r.value === 'string' || r.value === null) return r.value;\n    if (typeof r.data === 'string' || r.data === null) return r.data;\n    if (typeof r.result === 'string' || r.result === null) return r.result;\n  }\n\n  return null;\n}\n\nconst rawVal = getRedisValue(j);\nconst rawStr = (typeof rawVal === 'string') ? rawVal : '';\n\nlet cacheHit = false;\nlet cacheParseOk = false;\nlet cachedRecord = null;\nlet cacheError = null;\n\nif (rawStr && rawStr.trim().length > 0) {\n  try {\n    cachedRecord = JSON.parse(rawStr);\n    cacheParseOk = true;\n    cacheHit = true;\n  } catch (e) {\n    cacheError = `cache_json_parse_error: ${String(e)}`;\n  }\n}\n\nreturn {\n  json: {\n    ...j,\n    cacheHit,\n    cacheParseOk,\n    cacheError,\n    cachedRecord,\n    cacheValuePreview: rawStr.length > 500 ? rawStr.slice(0, 500) + '...(truncated)' : rawStr\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1600,
        360
      ],
      "id": "6cca2c17-d8f9-4573-b502-6641aaf357a5",
      "name": "Interpret Cache dfs-taint"
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.cacheHit }}",
              "operation": "isTrue"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        1800,
        360
      ],
      "id": "0723c099-af72-45e7-983b-dba4a1a8effc",
      "name": "If Cache Hit dfs-taint"
    },
    {
      "parameters": {
        "jsCode": "// Use cachedRecord for dfs-taint\nconst j = $json || {};\nconst rec = j.cachedRecord;\nlet findings = [];\nif (rec) {\n  if (Array.isArray(rec.findings)) findings = rec.findings;\n  else if (Array.isArray(rec)) findings = rec;\n  else if (typeof rec === 'object') findings = [rec];\n}\nreturn [{\n  json: {\n    ...j,\n    line: \"dfs-taint\",\n    cacheHit: true,\n    cacheMeta: rec && rec.meta ? rec.meta : undefined,\n    cacheSavedAt: rec && rec.savedAt ? rec.savedAt : undefined,\n    parseOk: j.cacheParseOk === true,\n    parseError: j.cacheError || \"\",\n    findings\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2000,
        300
      ],
      "id": "09ec94d4-d778-4945-90bb-c9c50f587bbc",
      "name": "Use Cached dfs-taint"
    },
    {
      "parameters": {
        "jsCode": "const cfg = $json.scanConfig || {};\nconst lim = cfg.limits && cfg.limits.dfsTaint ? cfg.limits.dfsTaint : {};\nconst callLimit = lim.callLimit || 28;\n\nconst ctx = $json.stageAContext || {};\nconst hintEntryClasses = Array.isArray(ctx.entryClasses) ? ctx.entryClasses : [];\nconst hintSuspectTypes = Array.isArray(ctx.suspectTypes) ? ctx.suspectTypes : [];\nconst configUsage = $json.configUsageContext || $node[\"Config Usage Context\"]?.json?.configUsageContext || $node[\"Global Context Hub\"]?.json?.configUsageContext || {};\nconst hintConfigMethods = Array.isArray(configUsage.methods) ? configUsage.methods : [];\nconst hintConfigKeys = Array.isArray(configUsage.keys) ? configUsage.keys : [];\n\nconst hintSinkNames = Array.isArray(ctx.sinkNames) ? ctx.sinkNames : [];\n\nconst baseSinkNames = Array.isArray(lim.sinkNames) && lim.sinkNames.length ? lim.sinkNames : [\"Runtime.exec(String)\"];\n\nconst typeToSinks = {\n  command_execution: [\"Runtime.exec(String)\", \"ProcessBuilder.start\", \"ScriptEngine.eval\"],\n  sql_injection: [\"Statement.executeQuery\", \"Statement.executeUpdate\", \"Connection.prepareStatement\"],\n  jndi_injection: [\"InitialContext.lookup\", \"Context.lookup\", \"DirContext.search\", \"LdapContext.search\"],\n  insecure_deserialization: [\"ObjectInputStream.readObject\", \"XMLDecoder.readObject\", \"Yaml.load\", \"JSON.parseObject\", \"ObjectMapper.readValue\", \"HessianInput.readObject\", \"XStream.fromXML\"],\n  ssrf: [\"URL.openConnection\", \"HttpURLConnection.connect\"],\n  file_io: [\"FileInputStream.new\", \"FileOutputStream.new\", \"RandomAccessFile.new\", \"File.delete\"]\n};\n\nconst preferred = new Set();\nfor (const t of hintSuspectTypes) {\n  const key = String(t || '').toLowerCase();\n  if (typeToSinks[key]) {\n    for (const s of typeToSinks[key]) preferred.add(s);\n  } else {\n    // fuzzy map\n    if (key.includes('sql')) typeToSinks.sql_injection.forEach(s => preferred.add(s));\n    if (key.includes('jndi')) typeToSinks.jndi_injection.forEach(s => preferred.add(s));\n    if (key.includes('deserial')) typeToSinks.insecure_deserialization.forEach(s => preferred.add(s));\n    if (key.includes('ssrf')) typeToSinks.ssrf.forEach(s => preferred.add(s));\n    if (key.includes('file')) typeToSinks.file_io.forEach(s => preferred.add(s));\n    if (key.includes('cmd') || key.includes('exec') || key.includes('command')) typeToSinks.command_execution.forEach(s => preferred.add(s));\n  }\n}\nfor (const s of hintSinkNames) preferred.add(s);\n\nconst sinkNames = Array.from(new Set([...(preferred.size ? Array.from(preferred) : []), ...baseSinkNames]));\nconst depth = lim.depth || 10;\nconst maxLimit = lim.maxLimit || 80;\nconst maxPaths = lim.maxPaths || 80;\nconst timeoutMs = lim.timeoutMs || 90000;\nconst onlyFromWeb = lim.onlyFromWeb !== false;\nconst resultLimit = lim.resultLimit || 120;\nconst compact = lim.compact !== false;\n\nconst hintLines = [];\nif (hintConfigMethods.length) hintLines.push(`Config methods(${hintConfigMethods.length}): ${hintConfigMethods.slice(0, 10).join(', ')}`);\nif (hintConfigKeys.length) hintLines.push(`Config keys: ${hintConfigKeys.slice(0, 10).join(', ')}`);\nif (hintEntryClasses.length) hintLines.push(`?????(${hintEntryClasses.length}): ${hintEntryClasses.slice(0, 12).join(', ')}`);\nif (hintSuspectTypes.length) hintLines.push(`????: ${hintSuspectTypes.join(', ')}`);\nconst hintBlock = hintLines.length ? `\n[Hints]\n${hintLines.join('\n')}\n` : '';\n\nconst chatInput = `\n????? **dfs-taint**????DFS/??????????????????\n?????? sink ?? DFS ?????? source??? onlyFromWeb????????? findings?\n${hintBlock}\n???????????\n1) ? sinkName ? ${JSON.stringify(sinkNames)} ?????\n   - get_dfs_chains(mode=\"sink\", sinkName=sinkName, searchAllSources=true, depth=${depth}, maxLimit=${maxLimit}, maxPaths=${maxPaths}, timeoutMs=${timeoutMs}, onlyFromWeb=${onlyFromWeb})\n   ????? jobId\n2) ??? jobId?\n   - ?? get_dfs_job(jobId) ?? status ? finished/done ? error?????????\n   - ????? get_dfs_results(jobId, limit=${resultLimit}, offset=0, compact=${compact})\n3) ??? DFSResult ??? finding?\n   - type??? sinkName ???command_exec/sql/jndi/deserialization/ssrf/file_io ??\n   - severity??? high??????\n   - confidence?high/medium?onlyFromWeb=true ????\n   - trace??? results.items[].methods?compact=true ?????? methods??? source ? sink ?????\n???\n- ?? job ?????? truncated????? 1 ????? findings?reason ?? truncated/recommend\n- ????? []\n`;\nreturn [{ json: { ...$json, line: \"dfs-taint\", callLimit, chatInput } }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2000,
        420
      ],
      "id": "374f7b98-30d3-4b5b-aabc-e6e5e8c8a5d5",
      "name": "Build Prompt dfs-taint"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.chatInput }}",
        "options": {
          "systemMessage": "你是资深 Java 安全审计工程师，目标是做自动化安全审计（静态分析）。\n必须遵守：\n1) 只能使用当前可用的 MCP 工具获取事实证据；禁止凭空猜测。\n2) 严格控制输出规模：优先使用批量/limit/compact/totalLimit 参数。\n3) 只输出 JSON 数组（不要输出解释、不要 Markdown、不要代码块围栏）。没有发现则输出 []。\n4) findings 数组元素必须包含字段：\n   - line (string)\n   - type (string)\n   - severity (\"high\"|\"medium\"|\"low\")\n   - confidence (\"high\"|\"medium\"|\"low\")\n   - score (1-10 整数)\n   - reason (string, 简洁说明命中原因与证据点)\n   - trace (array, 每项包含 {\"class\",\"method\",\"desc\"}；desc 可为空字符串)\n可以附加 evidence/metadata 等字段，但不要输出大段源码全文。",
          "maxIterations": "={{ $json.callLimit }}"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2.2,
      "position": [
        2200,
        420
      ],
      "id": "41e37e67-e75c-450b-a4bf-02965fc4c2a4",
      "name": "Agent dfs-taint",
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "jsCode": "// Parse AI Agent output into {line, findings[]} while preserving context fields (e.g., cacheKey/projectKey).\nconst ctx = $json || {};\nconst line = ctx.line || (ctx.context && ctx.context.line) || \"unknown\";\n\nfunction extractText(v) {\n  if (v === null || v === undefined) return \"\";\n  if (typeof v === \"string\") return v;\n  try { return JSON.stringify(v); } catch (e) { return String(v); }\n}\n\nlet raw = ctx.output ?? ctx.text ?? ctx.data ?? ctx;\nlet s = extractText(raw).trim();\n\n// Strip markdown fences if present\nconst fence = s.match(/```json\\s*([\\s\\S]*?)```/i);\nif (fence && fence[1]) s = fence[1].trim();\n\nlet findings = [];\nlet parseOk = false;\nlet parseError = \"\";\n\nif (!s) {\n  parseError = \"empty_response\";\n} else {\n  try {\n    const obj = JSON.parse(s);\n    if (Array.isArray(obj)) {\n      findings = obj;\n      parseOk = true;\n    } else if (obj && typeof obj === \"object\") {\n      if (Array.isArray(obj.findings)) {\n        findings = obj.findings;\n        parseOk = true;\n      } else if (Array.isArray(obj.data)) {\n        findings = obj.data;\n        parseOk = true;\n      } else {\n        parseError = \"json_object_without_findings_array\";\n      }\n    } else {\n      parseError = \"json_not_array\";\n    }\n  } catch (e) {\n    parseError = e.message || String(e);\n  }\n}\n\nreturn [{\n  json: {\n    ...ctx,\n    line,\n    parseOk,\n    parseError,\n    findings: Array.isArray(findings) ? findings : []\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2400,
        420
      ],
      "id": "37b89d74-a825-46e4-8a4f-08688e32cddf",
      "name": "Parse dfs-taint"
    },
    {
      "parameters": {
        "jsCode": "// Prepare cacheValue JSON for dfs-taint\nconst j = $json || {};\nif (j.parseOk !== true) {\n  return [];\n}\nconst cacheValue = JSON.stringify({\n  line: \"dfs-taint\",\n  savedAt: new Date().toISOString(),\n  meta: {\n    projectKey: j.projectKey,\n    strategyVersion: j.strategyVersion,\n    scanConfigHash: j.scanConfigHash,\n    rulesHash: j.rulesHash,\n    filterHash: j.filterHash\n  },\n  findings: Array.isArray(j.findings) ? j.findings : []\n});\nreturn [{\n  json: {\n    ...j,\n    cacheValue\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2600,
        420
      ],
      "id": "51dc9025-e9c3-47aa-99e6-97fdfbe0b83d",
      "name": "Prepare Cache Value dfs-taint"
    },
    {
      "parameters": {
        "operation": "set",
        "key": "={{ $json.cacheKey }}",
        "value": "={{ $json.cacheValue }}",
        "keyType": "string",
        "expire": true,
        "ttl": "={{ $json.cacheTtlSeconds }}"
      },
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [
        2800,
        420
      ],
      "id": "a7a26d79-048b-4bdd-a79c-ecb1b76ae8d1",
      "name": "Redis SET dfs-taint",
      "continueOnFail": true,
      "retryOnFail": true,
      "maxTries": 2,
      "waitBetweenTries": 500,
      "credentials": {
        "redis": {
          "id": "REPLACE_WITH_YOUR_REDIS_CREDENTIAL_ID",
          "name": "Redis account"
        }
      },
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "numberInputs": 7
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        3000,
        120
      ],
      "id": "9e0ab6bb-27a6-4c6c-8332-723051b9afdf",
      "name": "Merge Lines"
    },
    {
      "parameters": {
        "jsCode": "// Collect findings from 5 lines (Redis version), normalize schema, de-duplicate,\n// and output one item per unique finding that is NOT already covered by cacheHit results.\nconst inputs = $input.all();\n\nconst allowedSev = new Set(['high','medium','low']);\nconst allowedConf = new Set(['high','medium','low']);\n\nfunction normStr(v) {\n  if (v === null || v === undefined) return '';\n  return String(v);\n}\n\nfunction normLevel(v, defVal) {\n  const s = normStr(v).trim().toLowerCase();\n  if (allowedSev.has(s)) return s;\n  if (allowedConf.has(s)) return s;\n  return defVal;\n}\n\nfunction normalizeClassName(c) {\n  const s = normStr(c).trim();\n  if (!s) return '';\n  return s.replace(/\\//g, '.');\n}\n\nfunction normalizeTrace(trace, fallback) {\n  let t = [];\n  if (Array.isArray(trace)) {\n    t = trace.map(x => {\n      const o = (x && typeof x === 'object') ? x : {};\n      return {\n        class: normalizeClassName(o.class || o.className || o.cls || ''),\n        method: normStr(o.method || o.methodName || '').trim(),\n        desc: normStr(o.desc || o.methodDesc || '').trim(),\n      };\n    }).filter(x => x.class || x.method || x.desc);\n  }\n  if (!t.length && fallback) {\n    t = [fallback].filter(x => x.class || x.method || x.desc);\n  }\n  if (!t.length) t = [{class:'', method:'', desc:''}];\n  return t;\n}\n\nfunction clampInt(n, min, max) {\n  const x = parseInt(n, 10);\n  if (Number.isNaN(x)) return null;\n  return Math.min(max, Math.max(min, x));\n}\n\nfunction scoreBy(sev, conf) {\n  const s = sev || 'low';\n  const c = conf || 'low';\n  const table = {\n    'high':   {'high':9, 'medium':8, 'low':7},\n    'medium': {'high':7, 'medium':6, 'low':5},\n    'low':    {'high':4, 'medium':3, 'low':2},\n  };\n  return table[s]?.[c] ?? 3;\n}\n\nfunction maskSecret(v) {\n  const s = normStr(v).trim();\n  if (s.length <= 8) return s ? (s[0] + '***') : '';\n  return s.slice(0,4) + '***' + s.slice(-4);\n}\n\nfunction canonicalType(line, type, f) {\n  const t = normStr(type).trim();\n  const ruleName = normStr(f.ruleName || f.rule || f.name || '').trim();\n  const sinkName = normStr(f.sinkName || f.sink || '').trim();\n\n  if (t.startsWith('vul-rule::')) return t;\n\n  if (line === 'vul-rules') {\n    if (ruleName) return `vul-rule::${ruleName}`;\n    if (t) return `vul-rule::${t}`;\n  }\n\n  const sname = sinkName || t;\n  if (/Runtime\\.exec/i.test(sname) || /ProcessBuilder/i.test(sname)) return 'command_execution';\n  if (/InitialContext\\.lookup/i.test(sname) || /Context\\.lookup/i.test(sname) || /DirContext\\.search/i.test(sname) || /LdapContext\\.search/i.test(sname)) return 'jndi_injection';\n  if (/Statement\\.execute|executeQuery|executeUpdate|prepareStatement/i.test(sname)) return 'sql_injection';\n  if (/ObjectInputStream\\.readObject|XMLDecoder\\.readObject|Hessian.*readObject|XStream\\.fromXML|Yaml\\.load|JSON\\.parseObject|ObjectMapper\\.readValue/i.test(sname)) return 'insecure_deserialization';\n  if (/URL\\.openConnection|HttpURLConnection\\.connect/i.test(sname)) return 'ssrf';\n  if (/File(Input|Output)Stream\\.new|RandomAccessFile\\.new|File\\.delete/i.test(sname)) return 'file_io';\n\n  if (line === 'sca-leak') {\n    if (t === 'secret_leak') return 'secret_leak';\n    if (t === 'dependency_cve') return 'dependency_cve';\n    if (t === 'gadget_presence' || t === 'deserialization_gadget') return t;\n  }\n\n  if (t) return t;\n  return 'unknown';\n}\n\nfunction normalizeFinding(line, f, fromCache) {\n  const obj = (f && typeof f === 'object') ? f : {};\n  const out = {};\n\n  out.line = normStr(obj.line || line || 'unknown').trim() || 'unknown';\n  out.fromCache = !!fromCache;\n\n  out.ruleName = normStr(obj.ruleName || obj.rule || obj.name || '').trim() || undefined;\n  out.sinkName = normStr(obj.sinkName || obj.sink || '').trim() || undefined;\n  out.type = canonicalType(out.line, obj.type, { ...obj, ruleName: out.ruleName, sinkName: out.sinkName });\n\n  let sev = normLevel(obj.severity, 'low');\n  let conf = normLevel(obj.confidence, 'low');\n\n  if (out.type === 'secret_leak') { sev = 'high'; conf = 'high'; }\n\n  const cvss = obj.cvss ?? (obj.evidence && obj.evidence.cvss);\n  const cvssNum = typeof cvss === 'number' ? cvss : parseFloat(cvss);\n  if (out.type === 'dependency_cve' && !Number.isNaN(cvssNum)) {\n    if (cvssNum >= 9.0) sev = 'high';\n    else if (cvssNum >= 7.0) sev = 'medium';\n    else sev = 'low';\n    conf = 'high';\n  }\n\n  out.severity = allowedSev.has(sev) ? sev : 'low';\n  out.confidence = allowedConf.has(conf) ? conf : 'low';\n\n  let score = clampInt(obj.score, 1, 10);\n  if (score === null) {\n    if (out.type === 'dependency_cve' && !Number.isNaN(cvssNum)) {\n      score = Math.max(1, Math.min(10, Math.round(cvssNum)));\n    } else {\n      score = scoreBy(out.severity, out.confidence);\n    }\n  }\n  out.score = score;\n\n  const fallback = {\n    class: normalizeClassName(obj.className || obj.class || ''),\n    method: normStr(obj.methodName || obj.method || '').trim(),\n    desc: normStr(obj.methodDesc || obj.desc || '').trim(),\n  };\n  out.trace = normalizeTrace(obj.trace, fallback);\n\n  let reason = normStr(obj.reason || '').trim();\n  if (!reason) {\n    if (out.type === 'secret_leak') {\n      const tn = normStr(obj.typeName || (obj.evidence && obj.evidence.typeName) || '').trim();\n      const val = maskSecret(obj.value || (obj.evidence && obj.evidence.value));\n      reason = `Potential secret leak (${tn}) value=${val}`;\n    } else if (out.type === 'dependency_cve') {\n      const cve = normStr(obj.cve || (obj.evidence && obj.evidence.cve) || '').trim();\n      const proj = normStr(obj.project || (obj.evidence && obj.evidence.project) || '').trim();\n      const ver = normStr(obj.version || (obj.evidence && obj.evidence.version) || '').trim();\n      reason = `Dependency vulnerability ${cve} ${proj} ${ver}`.trim();\n    } else if (out.type.startsWith('vul-rule::')) {\n      reason = `Rule hit: ${out.type}`;\n    } else {\n      reason = `${out.type} hit`;\n    }\n  }\n  if (reason.length > 500) reason = reason.slice(0, 500) + '...';\n  out.reason = reason;\n\n  if (obj.evidence && typeof obj.evidence === 'object') {\n    out.evidence = obj.evidence;\n  } else {\n    const ev = {};\n    for (const k of ['jarName','jarPath','actualPath','restfulType','path','value','typeName','cve','cvss','project','version','matchedJarNames','matchedJarPaths']) {\n      if (obj[k] !== undefined && obj[k] !== null && normStr(obj[k]).trim() !== '') ev[k] = obj[k];\n    }\n    if (Object.keys(ev).length) out.evidence = ev;\n  }\n\n  return out;\n}\n\nfunction dedupKey(f) {\n  const t0 = f.trace && f.trace.length ? f.trace[0] : {class:'', method:'', desc:''};\n  const anchor = `${t0.class}#${t0.method}${t0.desc ? ':'+t0.desc : ''}`;\n  const extra = f.ruleName ? `|rule=${f.ruleName}` : (f.sinkName ? `|sink=${f.sinkName}` : '');\n  if (f.type === 'secret_leak') {\n    const tn = normStr(f.evidence && f.evidence.typeName || '');\n    const val = maskSecret(f.evidence && f.evidence.value || '');\n    return `${f.type}|${tn}|${val}|${anchor}`;\n  }\n  if (f.type === 'dependency_cve') {\n    const cve = normStr(f.evidence && f.evidence.cve || '');\n    const jar = normStr(f.evidence && f.evidence.jarPath || f.evidence && f.evidence.jarName || '');\n    return `${f.type}|${cve}|${jar}|${anchor}`;\n  }\n  return `${f.type}|${anchor}${extra}`;\n}\n\nfunction rank(f) {\n  const cw = {high:3, medium:2, low:1};\n  return (cw[f.confidence] || 1) * 100 + (cw[f.severity] || 1) * 10 + (f.score || 0);\n}\n\n// Collect all findings with cache flags\nconst all = [];\nfor (const it of inputs) {\n  const line = it.json && it.json.line ? it.json.line : 'unknown';\n  const fromCache = it.json && it.json.cacheHit === true;\n  const arr = Array.isArray(it.json && it.json.findings) ? it.json.findings : [];\n  for (const f of arr) all.push({ line, f, fromCache });\n}\n\n// Normalize, track cached keys, and dedup by best rank\nconst cachedKeys = new Set();\nconst best = new Map();\n\nfor (const {line, f, fromCache} of all) {\n  const nf = normalizeFinding(line, f, fromCache);\n  const key = dedupKey(nf);\n  nf.dedupKey = key;\n\n  if (fromCache) cachedKeys.add(key);\n\n  const prev = best.get(key);\n  if (!prev || rank(nf) > rank(prev)) best.set(key, nf);\n}\n\nconst unique = Array.from(best.values())\n  .filter(f => !cachedKeys.has(f.dedupKey)) // do not re-report keys already in cache\n  .sort((a,b) => rank(b) - rank(a));\n\n// Output items\nreturn unique.map(f => ({ json: f }));"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3200,
        120
      ],
      "id": "cc6f2c6e-6338-46a1-a940-632c4930408f",
      "name": "Collect Normalize Dedup"
    },
    {
      "parameters": {
        "batchSize": 1,
        "options": {}
      },
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [
        3400,
        120
      ],
      "id": "943ea35d-bfb3-4170-a6b8-d4cb7b622130",
      "name": "Loop Findings"
    },
    {
      "parameters": {
        "amount": 200,
        "unit": "milliseconds"
      },
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1,
      "position": [
        3600,
        120
      ],
      "id": "02bdcccd-f216-402a-bce4-63ace8b05294",
      "name": "Rate Limit"
    },
    {
      "parameters": {
        "jsCode": "// Build a deterministic instruction for the reporter agent to call MCP report tool exactly once.\nconst f = $json || {};\nconst type = String(f.type || 'unknown');\nconst reason = String(f.reason || '').trim() || `${type} hit`;\nconst score = (typeof f.score === 'number' ? f.score : parseInt(f.score, 10)) || 5;\n\nlet trace = [];\nif (Array.isArray(f.trace)) {\n  trace = f.trace.map(x => ({\n    class: String(x.class ?? '').replace(/\\//g,'.'),\n    method: String(x.method ?? ''),\n    desc: String(x.desc ?? ''),\n  }));\n}\nif (!trace.length) trace = [{class:'', method:'', desc:''}];\n\nconst payload = { type, reason, score, trace };\n\nconst chatInput = `请使用工具 report 上报以下漏洞。必须只调用一次 report 工具并传入完整 JSON；调用后只输出 {\"ok\":true}。\nreport 参数 JSON：\n${JSON.stringify(payload, null, 2)}\n`;\n\nreturn [{ json: { ...f, callLimit: 2, chatInput, reportPayload: payload } }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3800,
        120
      ],
      "id": "f24178d9-0c98-418d-a1f9-bf6dce108fb6",
      "name": "Build Report Prompt"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.chatInput }}",
        "options": {
          "systemMessage": "你是漏洞报告机器人。\n必须遵守：\n1) 你必须调用一次且仅一次名为 report 的工具来上报漏洞；参数必须严格使用输入中提供的 JSON（不要更改字段名、不要自作主张补充虚构数据）。\n2) 如果输入缺字段，使用空字符串/默认值，但仍需调用 report。\n3) 工具调用完成后，只输出一个 JSON：{\"ok\":true}。不要输出其他解释。",
          "maxIterations": "={{ $json.callLimit }}"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2.2,
      "position": [
        4000,
        120
      ],
      "id": "1a7803ca-6d6f-4c94-89a3-fd0a5a913a54",
      "name": "Reporter Agent",
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "jsCode": "// Workflow finished.\nreturn [{json:{ok:true, message:\"Audit workflow finished\"}}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        4200,
        240
      ],
      "id": "3271c337-b1f6-4be8-8625-eff8884d29df",
      "name": "Done"
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.scanConfig.enableGraphLite }}",
              "operation": "isTrue"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        1000,
        -180
      ],
      "id": "963c237e-a1fb-40dc-aea3-0b006fc65454",
      "name": "If Enable graph-lite"
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.scanConfig.enableVulRules }}",
              "operation": "isTrue"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        1000,
        0
      ],
      "id": "530c0c08-da99-4304-a763-c628ae1237f5",
      "name": "If Enable vul-rules"
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.scanConfig.enableScaLeak }}",
              "operation": "isTrue"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        1000,
        180
      ],
      "id": "164d6c62-8c28-44f0-a40e-be7b0c248f90",
      "name": "If Enable sca-leak"
    },
    {
      "parameters": {
        "jsCode": "// graph-lite disabled: return empty findings placeholder so merge can proceed.\nreturn [{\n  json: {\n    line: \"graph-lite\",\n    parseOk: true,\n    parseError: \"disabled\",\n    findings: []\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1200,
        -60
      ],
      "id": "9b502a2e-3874-4ed0-813b-fc133df90e5d",
      "name": "Graph-lite Disabled"
    },
    {
      "parameters": {
        "jsCode": "// vul-rules disabled: return empty findings placeholder so merge can proceed.\nreturn [{\n  json: {\n    line: \"vul-rules\",\n    parseOk: true,\n    parseError: \"disabled\",\n    findings: []\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1200,
        120
      ],
      "id": "9f16a145-e2a0-48d2-be89-bc92b58940bf",
      "name": "Vul-rules Disabled"
    },
    {
      "parameters": {
        "jsCode": "// sca-leak disabled: return empty findings placeholder so merge can proceed.\nreturn [{\n  json: {\n    line: \"sca-leak\",\n    parseOk: true,\n    parseError: \"disabled\",\n    findings: []\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1200,
        300
      ],
      "id": "d2ff728b-49e8-4090-afdf-54fc28b9a000",
      "name": "Sca-leak Disabled"
    },
    {
      "parameters": {
        "url": "={{ $('Global Constants').first().json.constants['jar-analyzer-api'] }}api/get_all_servlets",
        "options": {
          "headers": {
            "Token": "={{ $('Global Constants').first().json.constants['jar-analyzer-api-token'] || '' }}"
          }
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        400,
        -560
      ],
      "id": "5132753b-8787-4a78-9c6e-8f99a9c288e4",
      "name": "AuditFast Get All Servlet"
    },
    {
      "parameters": {
        "url": "={{ $('Global Constants').first().json.constants['jar-analyzer-api'] }}api/get_all_filters",
        "options": {
          "headers": {
            "Token": "={{ $('Global Constants').first().json.constants['jar-analyzer-api-token'] || '' }}"
          }
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        400,
        -480
      ],
      "id": "6dd131f7-5bc9-4e7f-861f-fa6d0a2b490d",
      "name": "AuditFast Get All Filter"
    },
    {
      "parameters": {
        "url": "={{ $('Global Constants').first().json.constants['jar-analyzer-api'] }}api/get_all_listeners",
        "options": {
          "headers": {
            "Token": "={{ $('Global Constants').first().json.constants['jar-analyzer-api-token'] || '' }}"
          }
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        400,
        -400
      ],
      "id": "491230b8-8a3f-41b4-97b1-9dac4c097756",
      "name": "AuditFast Get All Listener"
    },
    {
      "parameters": {
        "url": "={{ $('Global Constants').first().json.constants['jar-analyzer-api'] }}api/get_all_spring_controllers",
        "options": {
          "headers": {
            "Token": "={{ $('Global Constants').first().json.constants['jar-analyzer-api-token'] || '' }}"
          }
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        400,
        -320
      ],
      "id": "13969d6d-86c9-4f07-a18b-f2c55a2668b4",
      "name": "AuditFast Get All Spring Controller"
    },
    {
      "parameters": {
        "url": "={{ $('Global Constants').first().json.constants['jar-analyzer-api'] }}api/get_all_spring_interceptors",
        "options": {
          "headers": {
            "Token": "={{ $('Global Constants').first().json.constants['jar-analyzer-api-token'] || '' }}"
          }
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        400,
        -240
      ],
      "id": "a563b708-184f-46b3-9b5a-8d291feca00f",
      "name": "AuditFast Get All Spring Interceptor"
    },
    {
      "parameters": {
        "jsCode": "// Normalize API output into {className, entryType}\nconst items = $input.all();\nconst out = [];\n\nfunction pushVal(v) {\n  if (!v) return;\n  if (typeof v === 'string') {\n    out.push({ json: { className: v.trim(), entryType: \"servlet\" } });\n    return;\n  }\n  if (typeof v === 'object') {\n    const cn = v.className || v.class || v.name;\n    if (cn) out.push({ json: { className: String(cn).trim(), entryType: \"servlet\" } });\n  }\n}\n\nfor (const it of items) {\n  const j = it.json;\n  if (Array.isArray(j)) {\n    for (const v of j) pushVal(v);\n    continue;\n  }\n  if (j && typeof j === 'object') {\n    const arr = Array.isArray(j.data) ? j.data\n      : Array.isArray(j.items) ? j.items\n      : Array.isArray(j.result) ? j.result\n      : Array.isArray(j.list) ? j.list\n      : null;\n    if (arr) {\n      for (const v of arr) pushVal(v);\n      continue;\n    }\n  }\n  pushVal(j);\n}\n\nreturn out;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        620,
        -560
      ],
      "id": "57bebd20-5900-4054-88f0-d982284b8e37",
      "name": "AuditFast Tag Servlet"
    },
    {
      "parameters": {
        "jsCode": "// Normalize API output into {className, entryType}\nconst items = $input.all();\nconst out = [];\n\nfunction pushVal(v) {\n  if (!v) return;\n  if (typeof v === 'string') {\n    out.push({ json: { className: v.trim(), entryType: \"filter\" } });\n    return;\n  }\n  if (typeof v === 'object') {\n    const cn = v.className || v.class || v.name;\n    if (cn) out.push({ json: { className: String(cn).trim(), entryType: \"filter\" } });\n  }\n}\n\nfor (const it of items) {\n  const j = it.json;\n  if (Array.isArray(j)) {\n    for (const v of j) pushVal(v);\n    continue;\n  }\n  if (j && typeof j === 'object') {\n    const arr = Array.isArray(j.data) ? j.data\n      : Array.isArray(j.items) ? j.items\n      : Array.isArray(j.result) ? j.result\n      : Array.isArray(j.list) ? j.list\n      : null;\n    if (arr) {\n      for (const v of arr) pushVal(v);\n      continue;\n    }\n  }\n  pushVal(j);\n}\n\nreturn out;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        620,
        -480
      ],
      "id": "b3831ac2-b054-4f88-b132-9049e0a0c646",
      "name": "AuditFast Tag Filter"
    },
    {
      "parameters": {
        "jsCode": "// Normalize API output into {className, entryType}\nconst items = $input.all();\nconst out = [];\n\nfunction pushVal(v) {\n  if (!v) return;\n  if (typeof v === 'string') {\n    out.push({ json: { className: v.trim(), entryType: \"listener\" } });\n    return;\n  }\n  if (typeof v === 'object') {\n    const cn = v.className || v.class || v.name;\n    if (cn) out.push({ json: { className: String(cn).trim(), entryType: \"listener\" } });\n  }\n}\n\nfor (const it of items) {\n  const j = it.json;\n  if (Array.isArray(j)) {\n    for (const v of j) pushVal(v);\n    continue;\n  }\n  if (j && typeof j === 'object') {\n    const arr = Array.isArray(j.data) ? j.data\n      : Array.isArray(j.items) ? j.items\n      : Array.isArray(j.result) ? j.result\n      : Array.isArray(j.list) ? j.list\n      : null;\n    if (arr) {\n      for (const v of arr) pushVal(v);\n      continue;\n    }\n  }\n  pushVal(j);\n}\n\nreturn out;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        620,
        -400
      ],
      "id": "616574eb-3099-4d10-b888-1837fff06fa1",
      "name": "AuditFast Tag Listener"
    },
    {
      "parameters": {
        "jsCode": "// Normalize API output into {className, entryType}\nconst items = $input.all();\nconst out = [];\n\nfunction pushVal(v) {\n  if (!v) return;\n  if (typeof v === 'string') {\n    out.push({ json: { className: v.trim(), entryType: \"spring_controller\" } });\n    return;\n  }\n  if (typeof v === 'object') {\n    const cn = v.className || v.class || v.name;\n    if (cn) out.push({ json: { className: String(cn).trim(), entryType: \"spring_controller\" } });\n  }\n}\n\nfor (const it of items) {\n  const j = it.json;\n  if (Array.isArray(j)) {\n    for (const v of j) pushVal(v);\n    continue;\n  }\n  if (j && typeof j === 'object') {\n    const arr = Array.isArray(j.data) ? j.data\n      : Array.isArray(j.items) ? j.items\n      : Array.isArray(j.result) ? j.result\n      : Array.isArray(j.list) ? j.list\n      : null;\n    if (arr) {\n      for (const v of arr) pushVal(v);\n      continue;\n    }\n  }\n  pushVal(j);\n}\n\nreturn out;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        620,
        -320
      ],
      "id": "969f58f1-f94e-4805-acf2-822310cf0fb4",
      "name": "AuditFast Tag Spring Controller"
    },
    {
      "parameters": {
        "jsCode": "// Normalize API output into {className, entryType}\nconst items = $input.all();\nconst out = [];\n\nfunction pushVal(v) {\n  if (!v) return;\n  if (typeof v === 'string') {\n    out.push({ json: { className: v.trim(), entryType: \"spring_interceptor\" } });\n    return;\n  }\n  if (typeof v === 'object') {\n    const cn = v.className || v.class || v.name;\n    if (cn) out.push({ json: { className: String(cn).trim(), entryType: \"spring_interceptor\" } });\n  }\n}\n\nfor (const it of items) {\n  const j = it.json;\n  if (Array.isArray(j)) {\n    for (const v of j) pushVal(v);\n    continue;\n  }\n  if (j && typeof j === 'object') {\n    const arr = Array.isArray(j.data) ? j.data\n      : Array.isArray(j.items) ? j.items\n      : Array.isArray(j.result) ? j.result\n      : Array.isArray(j.list) ? j.list\n      : null;\n    if (arr) {\n      for (const v of arr) pushVal(v);\n      continue;\n    }\n  }\n  pushVal(j);\n}\n\nreturn out;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        620,
        -240
      ],
      "id": "cea1e748-a754-4ea6-8106-a1841b8badc7",
      "name": "AuditFast Tag Spring Interceptor"
    },
    {
      "parameters": {
        "numberInputs": 5
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        820,
        -400
      ],
      "id": "e8e1d285-0d0e-4fe3-b773-dd087c70fe1f",
      "name": "AuditFast Merge Entrypoints",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "jsCode": "// De-duplicate entrypoints and tag controller flag\nconst items = $input.all();\nconst map = new Map();\n\nfor (const it of items) {\n  const j = it.json || {};\n  const cn = (j.className || '').trim();\n  if (!cn) continue;\n  const t = (j.entryType || '').trim();\n  const prev = map.get(cn) || { className: cn, entryTypes: [] };\n  if (t && !prev.entryTypes.includes(t)) prev.entryTypes.push(t);\n  map.set(cn, prev);\n}\n\nconst out = [];\nfor (const v of map.values()) {\n  v.isController = v.entryTypes.includes('spring_controller');\n  v.entryType = v.entryTypes[0] || '';\n  out.push({ json: v });\n}\n\n// Optional: limit number of entries to avoid overload\nconst lim = ($node['Init Scan Config']?.json?.scanConfig?.limits?.auditFast) || {};\nconst entryLimit = lim.entryLimit || lim.mappingSampleLimit || 120;\nreturn out.slice(0, entryLimit);"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1000,
        -400
      ],
      "id": "47d89b29-a2b6-4eb3-8fd9-30a3bdbc629f",
      "name": "AuditFast Dedup Entrypoints"
    },
    {
      "parameters": {
        "url": "={{ $('Global Constants').first().json.constants['jar-analyzer-api'] }}api/get_class_by_class?class={{ $json.className }}",
        "options": {
          "headers": {
            "Token": "={{ $('Global Constants').first().json.constants['jar-analyzer-api-token'] || '' }}"
          }
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        1200,
        -400
      ],
      "id": "6521efef-3288-43d5-9852-d50d3a4ca705",
      "name": "AuditFast Get Class Info"
    },
    {
      "parameters": {
        "url": "={{ $('Global Constants').first().json.constants['jar-analyzer-api'] }}api/get_methods_by_class?class={{ $json.className }}",
        "options": {
          "headers": {
            "Token": "={{ $('Global Constants').first().json.constants['jar-analyzer-api-token'] || '' }}"
          }
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        1400,
        -400
      ],
      "id": "64ebfd1b-e89f-46f6-a3e0-b1f122030d31",
      "name": "AuditFast Get Methods"
    },
    {
      "parameters": {
        "jsCode": "// Collect method list for one entry and attach class info\nconst entry = $node['AuditFast Dedup Entrypoints']?.json || {};\nconst classInfo = $node['AuditFast Get Class Info']?.json || {};\nconst items = $input.all();\nlet methods = [];\n\nfunction pushMethod(v) {\n  if (!v) return;\n  if (typeof v !== 'object') return;\n  const m = {\n    methodName: v.methodName || v.method || v.name || '',\n    methodDesc: v.methodDesc || v.desc || v.signature || '',\n    isStatic: v.isStaticInt ?? v.isStatic ?? v.static ?? null\n  };\n  if (m.methodName || m.methodDesc) methods.push(m);\n}\n\nfor (const it of items) {\n  const j = it.json;\n  if (Array.isArray(j)) {\n    for (const v of j) pushMethod(v);\n    continue;\n  }\n  if (j && typeof j === 'object') {\n    const arr = Array.isArray(j.data) ? j.data\n      : Array.isArray(j.methods) ? j.methods\n      : Array.isArray(j.items) ? j.items\n      : Array.isArray(j.result) ? j.result\n      : null;\n    if (arr) {\n      for (const v of arr) pushMethod(v);\n      continue;\n    }\n  }\n  pushMethod(j);\n}\n\nreturn [{\n  json: {\n    ...entry,\n    classInfo,\n    methods\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1600,
        -400
      ],
      "id": "85ca921b-07e4-42af-aae1-148a747dc30c",
      "name": "AuditFast Collect Methods"
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.isController }}",
              "operation": "isTrue"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        1200,
        -260
      ],
      "id": "d1ebd7cd-23bc-44e9-93ee-802c37d14ba4",
      "name": "AuditFast If Controller"
    },
    {
      "parameters": {
        "url": "={{ $('Global Constants').first().json.constants['jar-analyzer-api'] }}api/get_spring_mappings?class={{ $json.className }}",
        "options": {
          "headers": {
            "Token": "={{ $('Global Constants').first().json.constants['jar-analyzer-api-token'] || '' }}"
          }
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        1400,
        -260
      ],
      "id": "147f6fb5-0b2e-48c3-a28d-a8992f1a4559",
      "name": "AuditFast Get Mappings"
    },
    {
      "parameters": {
        "jsCode": "// Normalize spring mappings into array\nconst items = $input.all();\nlet mappings = [];\n\nfunction pushMap(v) {\n  if (!v) return;\n  if (typeof v !== 'object') return;\n  mappings.push(v);\n}\n\nfor (const it of items) {\n  const j = it.json;\n  if (Array.isArray(j)) {\n    for (const v of j) pushMap(v);\n    continue;\n  }\n  if (j && typeof j === 'object') {\n    const arr = Array.isArray(j.data) ? j.data\n      : Array.isArray(j.mappings) ? j.mappings\n      : Array.isArray(j.items) ? j.items\n      : Array.isArray(j.result) ? j.result\n      : null;\n    if (arr) {\n      for (const v of arr) pushMap(v);\n      continue;\n    }\n  }\n  pushMap(j);\n}\n\nreturn [{ json: { mappings } }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1600,
        -260
      ],
      "id": "49baa879-a492-4e29-b997-13e18fa57a55",
      "name": "AuditFast Normalize Mappings"
    },
    {
      "parameters": {
        "jsCode": "// No mappings placeholder\nreturn [{ json: { mappings: [] } }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1400,
        -160
      ],
      "id": "a45875f9-b638-4db8-9a3c-e356661c554e",
      "name": "AuditFast No Mappings"
    },
    {
      "parameters": {
        "numberInputs": 2
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        1800,
        -330
      ],
      "id": "6b100812-b9e0-43ee-818d-bbf2fbd9866e",
      "name": "AuditFast Merge Context"
    },
    {
      "parameters": {
        "jsCode": "// Accumulate audit-fast findings across entry loop (per execution)\nconst j = $json || {};\nconst data = $getWorkflowStaticData('node');\nconst execId = $execution?.id || 'unknown';\n\ndata.findingsByExec = data.findingsByExec || {};\nconst arr = Array.isArray(data.findingsByExec[execId]) ? data.findingsByExec[execId] : [];\n\nif (j.parseOk === true && Array.isArray(j.findings)) {\n  arr.push(...j.findings);\n}\n\ndata.findingsByExec[execId] = arr;\n\n// Emit a lightweight item to drive the loop\nreturn [{ json: { ok: true } }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1400,
        -300
      ],
      "id": "1c71e400-4036-4219-bda1-1859b3240b4b",
      "name": "AuditFast Aggregate Findings"
    },
    {
      "parameters": {
        "jsCode": "// Combine methods + mappings context into a single item\nconst items = $input.all();\nif (!items.length) return [];\nif (items.length === 1) return items;\n\nconst out = {};\nfunction mergeArray(key, arr) {\n  if (!Array.isArray(arr)) return;\n  if (!Array.isArray(out[key])) out[key] = [];\n  for (const v of arr) out[key].push(v);\n}\n\nfor (const it of items) {\n  const j = it.json || {};\n  for (const [k, v] of Object.entries(j)) {\n    if (k === 'methods' || k === 'mappings' || k === 'entryTypes') {\n      mergeArray(k, v);\n      continue;\n    }\n    if (out[k] === undefined || out[k] === null || out[k] === '') {\n      out[k] = v;\n    }\n  }\n}\n\nreturn [{ json: out }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1960,
        -330
      ],
      "id": "2fd1b2ec-907f-4ca9-8dc5-91341c5bf1da",
      "name": "AuditFast Combine Context"
    },
    {
      "parameters": {
        "batchSize": 1,
        "options": {}
      },
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [
        1120,
        -400
      ],
      "id": "83cdd8ca-b673-4d99-8b04-c3379fd5feda",
      "name": "AuditFast Loop Entrypoints"
    },
    {
      "parameters": {
        "amount": 150,
        "unit": "milliseconds"
      },
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1,
      "position": [
        1240,
        -400
      ],
      "id": "63a26485-6419-4f21-928c-76f685dd7e2e",
      "name": "AuditFast Rate Limit"
    },
    {
      "parameters": {
        "jsCode": "// Flush accumulated audit-fast findings at end of loop (per execution, Redis workflow)\nconst data = $getWorkflowStaticData('node');\nconst execId = $execution?.id || 'unknown';\nconst findings = Array.isArray(data.findingsByExec?.[execId]) ? data.findingsByExec[execId] : [];\n\nif (data.findingsByExec && execId in data.findingsByExec) {\n  delete data.findingsByExec[execId];\n}\n\nconst baseCtx = $node['Build Cache Key audit-fast']?.json || {};\n\nreturn [{\n  json: {\n    ...baseCtx,\n    line: 'audit-fast',\n    parseOk: true,\n    parseError: '',\n    findings\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1400,
        -520
      ],
      "id": "d3ade40b-1b2d-4759-bafb-310867608efb",
      "name": "AuditFast Flush Findings"
    },
    {
      "parameters": {
        "jsCode": "// Reset audit-fast accumulator for this execution\nconst data = $getWorkflowStaticData('node');\nconst execId = $execution?.id || 'unknown';\n\ndata.findingsByExec = data.findingsByExec || {};\ndata.findingsByExec[execId] = [];\n\nreturn $input.all();"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1060,
        -400
      ],
      "id": "10108ada-83d2-4f69-b62f-fea201ebf11d",
      "name": "AuditFast Reset Accumulator"
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.className ? true : false }}",
              "operation": "isTrue"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        1080,
        -460
      ],
      "id": "800505dd-7343-4f03-8721-3656b1404b71",
      "name": "AuditFast Has Entrypoints"
    },
    {
      "parameters": {
        "jsCode": "// No entrypoints: output empty audit-fast findings\nreturn [{\n  json: {\n    line: 'audit-fast',\n    parseOk: true,\n    parseError: 'no_entrypoints',\n    findings: []\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1260,
        -520
      ],
      "id": "e33f8eda-f5da-40d6-9d9c-6941d0d5b065",
      "name": "AuditFast No Entrypoints"
    },
    {
      "parameters": {
        "jsCode": "// Emit parse error record for downstream visibility\nconst j = $json || {};\nif (j.parseOk === true) return [];\nreturn [{ json: { line: j.line || 'unknown', parseOk: false, parseError: j.parseError || '' } }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1200,
        -520
      ],
      "id": "1307a88c-2b53-492b-99ac-f3e478450b4e",
      "name": "Parse Error Tap"
    },
    {
      "parameters": {
        "jsCode": "// Convert parse errors into low-confidence findings for visibility\nconst items = $input.all();\nif (!items.length) return [];\nreturn items.map(it => {\n  const e = it.json || {};\n  const line = e.line || 'unknown';\n  return {\n    json: {\n      line,\n      type: 'parser_error',\n      severity: 'low',\n      confidence: 'low',\n      score: 1,\n      reason: `Parse error in ${line}: ${e.parseError || 'unknown'}`,\n      trace: [{ class: '', method: '', desc: '' }]\n    }\n  };\n});"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1400,
        -520
      ],
      "id": "ba1cd6f1-7921-442e-8adc-d96592538fde",
      "name": "Parse Errors To Findings"
    },
    {
      "parameters": {
        "url": "={{ $('Global Constants').first().json.constants['jar-analyzer-api'] }}api/get_sink_candidates",
        "options": {
          "headers": {
            "Token": "={{ $('Global Constants').first().json.constants['jar-analyzer-api-token'] || '' }}"
          }
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1200,
        220
      ],
      "id": "30f68fdd-7f52-4d0e-9d1a-140c47c1da6a",
      "name": "Get Sink Candidates dfs-taint"
    },
    {
      "parameters": {
        "jsCode": "const base = $node['If Cache Hit dfs-taint']?.json || $json || {};\nconst response = $json || {};\nlet items = [];\nif (Array.isArray(response)) items = response;\nelse if (Array.isArray(response?.items)) items = response.items;\nelse if (Array.isArray(response?.data)) items = response.data;\n\nconst sinkNames = items\n  .map(it => it?.sinkName || it?.boxName || it?.name)\n  .filter(Boolean);\n\nconst scanConfig = base.scanConfig || {};\nconst limits = scanConfig.limits || {};\nconst dfs = limits.dfsTaint || {};\nif (sinkNames.length) dfs.sinkNames = sinkNames;\nlimits.dfsTaint = dfs;\nscanConfig.limits = limits;\n\nreturn [{\n  json: {\n    ...base,\n    scanConfig,\n    sinkCandidates: items,\n    sinkCandidateCount: sinkNames.length\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1400,
        220
      ],
      "id": "d3490bba-4fb4-4a7b-8d64-9b7b1c3f5b4e",
      "name": "Apply Sink Candidates dfs-taint"
    },
    {
      "parameters": {
        "jsCode": "// Reset Stage A aggregator (per execution)\nconst data = $getWorkflowStaticData('node');\nconst execId = $execution?.id || 'unknown';\n\nconst scanConfig = $json.scanConfig || {};\nconst base = {\n  scanConfig,\n  jarCount: $json.jarCount ?? null,\n  jars: $json.jars || [],\n  projectKey: $json.projectKey,\n  strategyVersion: $json.strategyVersion,\n  scanConfigHash: $json.scanConfigHash,\n  rulesHash: $json.rulesHash,\n  filterHash: $json.filterHash\n};\n\nconst expect = {\n  auditFast: true,\n  scaLeak: scanConfig.enableScaLeak !== false,\n  vulRules: scanConfig.enableVulRules !== false\n};\n\nconst done = {\n  auditFast: false,\n  scaLeak: !expect.scaLeak,\n  vulRules: !expect.vulRules\n};\n\ndata.stageA = data.stageA || {};\ndata.stageA[execId] = {\n  base,\n  expect,\n  done,\n  findings: {}\n};\n\nreturn $input.all();\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        800,
        -300
      ],
      "id": "a2049a2e-66f8-4dc6-943e-da0ba99b91d5",
      "name": "Stage A Reset Context"
    },
    {
      "parameters": {
        "jsCode": "// Aggregate Stage A outputs (audit-fast / sca-leak / vul-rules) and build shared context\nconst data = $getWorkflowStaticData('node');\nconst execId = $execution?.id || 'unknown';\nconst state = data.stageA?.[execId];\nif (!state) return [];\n\nconst line = String($json.line || '').trim();\nconst findings = Array.isArray($json.findings) ? $json.findings : [];\n\nif (line) {\n  state.findings[line] = findings;\n  if (line === 'audit-fast') state.done.auditFast = true;\n  if (line === 'sca-leak') state.done.scaLeak = true;\n  if (line === 'vul-rules') state.done.vulRules = true;\n}\n\nconst allDone = state.done.auditFast && state.done.scaLeak && state.done.vulRules;\nif (!allDone) return [];\n\nfunction normStr(v) {\n  if (v === null || v === undefined) return '';\n  return String(v);\n}\n\nfunction maskSecret(v) {\n  const s = normStr(v).trim();\n  if (!s) return '';\n  if (s.length <= 8) return s[0] + '***';\n  return s.slice(0,4) + '***' + s.slice(-4);\n}\n\nfunction traceHead(f) {\n  const tr = Array.isArray(f?.trace) ? f.trace : [];\n  if (tr.length) return tr[0] || {};\n  return {\n    class: f?.className || f?.class || '',\n    method: f?.methodName || f?.method || ''\n  };\n}\n\nfunction traceTail(f) {\n  const tr = Array.isArray(f?.trace) ? f.trace : [];\n  if (tr.length) return tr[tr.length - 1] || {};\n  return {\n    class: f?.className || f?.class || '',\n    method: f?.methodName || f?.method || ''\n  };\n}\n\nfunction normType(t) {\n  const s = normStr(t).toLowerCase();\n  if (!s) return '';\n  if (s.includes('sql')) return 'sql_injection';\n  if (s.includes('jndi')) return 'jndi_injection';\n  if (s.includes('deserial')) return 'insecure_deserialization';\n  if (s.includes('ssrf')) return 'ssrf';\n  if (s.includes('file')) return 'file_io';\n  if (s.includes('cmd') || s.includes('command') || s.includes('exec')) return 'command_execution';\n  return s;\n}\n\nfunction toList(set, limit) {\n  return Array.from(set).slice(0, limit);\n}\n\nconst entryClasses = new Set();\nconst entryMethods = new Set();\nconst ruleNames = new Set();\nconst ruleMethods = new Set();\nconst leakValues = new Set();\nconst leakTypeNames = new Set();\nconst suspectTypes = new Set();\nconst sinkNames = new Set();\n\nconst auditFindings = state.findings['audit-fast'] || [];\nfor (const f of auditFindings) {\n  const h = traceHead(f);\n  const cls = normStr(h.class || h.className).trim().replace(/\\//g, '.');\n  const m = normStr(h.method || h.methodName).trim();\n  if (cls) entryClasses.add(cls);\n  if (m) entryMethods.add(m);\n  const t = normType(f?.type);\n  if (t) suspectTypes.add(t);\n  const sn = normStr(f?.sinkName || f?.sink || f?.evidence?.sinkName).trim();\n  if (sn) sinkNames.add(sn);\n}\n\nconst vulFindings = state.findings['vul-rules'] || [];\nfor (const f of vulFindings) {\n  const rn = normStr(f?.ruleName || f?.rule || f?.name).trim();\n  if (rn) ruleNames.add(rn);\n  const tail = traceTail(f);\n  const cls = normStr(tail.class || tail.className).trim().replace(/\\//g, '.');\n  const m = normStr(tail.method || tail.methodName).trim();\n  const rm = [cls, m].filter(Boolean).join('#');\n  if (rm) ruleMethods.add(rm);\n  const t = normType(f?.type || rn);\n  if (t) suspectTypes.add(t);\n  const sn = normStr(f?.sinkName || f?.sink || f?.evidence?.sinkName).trim();\n  if (sn) sinkNames.add(sn);\n}\n\nconst leakFindings = state.findings['sca-leak'] || [];\nfor (const f of leakFindings) {\n  const v = f?.value ?? f?.evidence?.value;\n  const tv = f?.typeName ?? f?.evidence?.typeName;\n  const masked = maskSecret(v);\n  if (masked) leakValues.add(masked);\n  if (tv) leakTypeNames.add(String(tv));\n}\n\nconst ctx = {\n  entryClasses: toList(entryClasses, 50),\n  entryMethods: toList(entryMethods, 50),\n  ruleNames: toList(ruleNames, 50),\n  ruleMethods: toList(ruleMethods, 50),\n  leakValues: toList(leakValues, 20),\n  leakTypeNames: toList(leakTypeNames, 20),\n  suspectTypes: toList(suspectTypes, 20),\n  sinkNames: toList(sinkNames, 50),\n  counts: {\n    auditFast: auditFindings.length,\n    scaLeak: leakFindings.length,\n    vulRules: vulFindings.length\n  }\n};\n\nconst out = {\n  ...state.base,\n  stageAContext: ctx\n};\n\ndelete data.stageA[execId];\nreturn [{ json: out }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1400,
        -300
      ],
      "id": "e263f3fd-002c-4a14-96ed-f40f376b3ff8",
      "name": "Stage A Aggregate Context"
    },
    {
      "parameters": {
        "jsCode": "// Reset Stage 0 (global hints) aggregator (per execution)\nconst data = $getWorkflowStaticData('node');\nconst execId = $execution?.id || 'unknown';\n\nconst scanConfig = $json.scanConfig || {};\nconst base = {\n  scanConfig,\n  jarCount: $json.jarCount ?? null,\n  jars: $json.jars || [],\n  projectKey: $json.projectKey,\n  strategyVersion: $json.strategyVersion,\n  scanConfigHash: $json.scanConfigHash,\n  rulesHash: $json.rulesHash,\n  filterHash: $json.filterHash\n};\n\nconst expect = {\n  scaLeak: scanConfig.enableScaLeak !== false,\n  vulRules: scanConfig.enableVulRules !== false\n};\n\nconst done = {\n  scaLeak: !expect.scaLeak,\n  vulRules: !expect.vulRules\n};\n\ndata.stage0 = data.stage0 || {};\ndata.stage0[execId] = {\n  base,\n  expect,\n  done,\n  findings: {}\n};\n\nreturn $input.all();\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        300,
        -300
      ],
      "id": "8a3a25ad-07d2-4c4a-b283-5b29b7e4d81b",
      "name": "Stage 0 Reset Context"
    },
    {
      "parameters": {
        "jsCode": "// Aggregate Stage 0 outputs (sca-leak / vul-rules) and build global hints\nconst data = $getWorkflowStaticData('node');\nconst execId = $execution?.id || 'unknown';\nconst state = data.stage0?.[execId];\nif (!state) return [];\n\nconst line = String($json.line || '').trim();\nconst findings = Array.isArray($json.findings) ? $json.findings : [];\n\nif (line) {\n  state.findings[line] = findings;\n  if (line === 'sca-leak') state.done.scaLeak = true;\n  if (line === 'vul-rules') state.done.vulRules = true;\n}\n\nconst allDone = state.done.scaLeak && state.done.vulRules;\nif (!allDone) return [];\n\nfunction normStr(v) {\n  if (v === null || v === undefined) return '';\n  return String(v);\n}\n\nfunction maskSecret(v) {\n  const s = normStr(v).trim();\n  if (!s) return '';\n  if (s.length <= 8) return s[0] + '***';\n  return s.slice(0,4) + '***' + s.slice(-4);\n}\n\nfunction normType(t) {\n  const s = normStr(t).toLowerCase();\n  if (!s) return '';\n  if (s.includes('sql')) return 'sql_injection';\n  if (s.includes('jndi')) return 'jndi_injection';\n  if (s.includes('deserial')) return 'insecure_deserialization';\n  if (s.includes('ssrf')) return 'ssrf';\n  if (s.includes('file')) return 'file_io';\n  if (s.includes('cmd') || s.includes('command') || s.includes('exec')) return 'command_execution';\n  return s;\n}\n\nfunction toList(set, limit) {\n  return Array.from(set).slice(0, limit);\n}\n\nconst ruleNames = new Set();\nconst ruleMethods = new Set();\nconst leakValues = new Set();\nconst leakTypeNames = new Set();\nconst suspectTypes = new Set();\nconst sinkNames = new Set();\n\nconst vulFindings = state.findings['vul-rules'] || [];\nfor (const f of vulFindings) {\n  const rn = normStr(f?.ruleName || f?.rule || f?.name).trim();\n  if (rn) ruleNames.add(rn);\n  const t = normType(f?.type || rn);\n  if (t) suspectTypes.add(t);\n  const sn = normStr(f?.sinkName || f?.sink || f?.evidence?.sinkName).trim();\n  if (sn) sinkNames.add(sn);\n\n  // pick method from trace tail when available\n  const tr = Array.isArray(f?.trace) ? f.trace : [];\n  const tail = tr.length ? tr[tr.length - 1] : null;\n  const cls = normStr(tail?.class || tail?.className).trim().replace(/\\//g, '.');\n  const m = normStr(tail?.method || tail?.methodName).trim();\n  const rm = [cls, m].filter(Boolean).join('#');\n  if (rm) ruleMethods.add(rm);\n}\n\nconst leakFindings = state.findings['sca-leak'] || [];\nfor (const f of leakFindings) {\n  const v = f?.value ?? f?.evidence?.value;\n  const tv = f?.typeName ?? f?.evidence?.typeName;\n  const masked = maskSecret(v);\n  if (masked) leakValues.add(masked);\n  if (tv) leakTypeNames.add(String(tv));\n  const t = normType(f?.type);\n  if (t) suspectTypes.add(t);\n}\n\nconst ctx = {\n  ruleNames: toList(ruleNames, 50),\n  ruleMethods: toList(ruleMethods, 50),\n  leakValues: toList(leakValues, 20),\n  leakTypeNames: toList(leakTypeNames, 20),\n  suspectTypes: toList(suspectTypes, 20),\n  sinkNames: toList(sinkNames, 50),\n  counts: {\n    scaLeak: leakFindings.length,\n    vulRules: vulFindings.length\n  }\n};\n\nconst out = {\n  ...state.base,\n  stage0Context: ctx\n};\n\ndelete data.stage0[execId];\nreturn [{ json: out }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        500,
        -300
      ],
      "id": "fd6c26ff-4ca4-4c60-925d-12420c3d7366",
      "name": "Stage 0 Aggregate Context"
    },
    {
      "parameters": {
        "jsCode": "// Build Redis cacheKey for line: config-usage\nconst strategyVersion = $json.strategyVersion || '5lines-v2';\nconst projectKey = $json.projectKey || 'unknown';\nconst scanConfigHash = $json.scanConfigHash || 'cfg0';\nconst rulesHash = $json.rulesHash || 'rules0';\nconst filterHash = $json.filterHash || 'filter0';\nconst cacheKey = `ja:5lines:${strategyVersion}:${projectKey}:${scanConfigHash}:${rulesHash}:${filterHash}:config-usage`;\n\nreturn [{\n  json: {\n    ...$json,\n    line: \"config-usage\",\n    cacheKey\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1000,
        520
      ],
      "id": "c1bd2a9e-ffdd-474e-8b16-c012e1d3519d",
      "name": "Build Cache Key config-usage"
    },
    {
      "parameters": {
        "operation": "get",
        "key": "={{ $json.cacheKey }}",
        "options": {}
      },
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [
        1200,
        520
      ],
      "id": "71b18de2-019d-442a-af5b-4053e543ee79",
      "name": "Redis GET config-usage",
      "continueOnFail": true,
      "retryOnFail": true,
      "maxTries": 2,
      "waitBetweenTries": 500,
      "credentials": {
        "redis": {
          "id": "REPLACE_WITH_YOUR_REDIS_CREDENTIAL_ID",
          "name": "Redis account"
        }
      },
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "jsCode": "// Interpret Redis GET output and decide cacheHit.\n// Expected Redis node shape for GET: { value: <string|null> }.\n// We only inspect known value fields to avoid accidentally treating other context strings as cache values.\nconst j = $json || {};\n\nfunction getRedisValue(obj) {\n  if (!obj || typeof obj !== 'object') return null;\n\n  if (typeof obj.value === 'string' || obj.value === null) return obj.value;\n  if (typeof obj.data === 'string' || obj.data === null) return obj.data;\n  if (typeof obj.result === 'string' || obj.result === null) return obj.result;\n\n  // Some variants may nest under \"redis\"\n  if (obj.redis && typeof obj.redis === 'object') {\n    const r = obj.redis;\n    if (typeof r.value === 'string' || r.value === null) return r.value;\n    if (typeof r.data === 'string' || r.data === null) return r.data;\n    if (typeof r.result === 'string' || r.result === null) return r.result;\n  }\n\n  return null;\n}\n\nconst rawVal = getRedisValue(j);\nconst rawStr = (typeof rawVal === 'string') ? rawVal : '';\n\nlet cacheHit = false;\nlet cacheParseOk = false;\nlet cachedRecord = null;\nlet cacheError = null;\n\nif (rawStr && rawStr.trim().length > 0) {\n  try {\n    cachedRecord = JSON.parse(rawStr);\n    cacheParseOk = true;\n    cacheHit = true;\n  } catch (e) {\n    cacheError = `cache_json_parse_error: ${String(e)}`;\n  }\n}\n\nreturn {\n  json: {\n    ...j,\n    cacheHit,\n    cacheParseOk,\n    cacheError,\n    cachedRecord,\n    cacheValuePreview: rawStr.length > 500 ? rawStr.slice(0, 500) + '...(truncated)' : rawStr\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1400,
        520
      ],
      "id": "a458d43c-6513-4c6b-8b5f-416b28bced2e",
      "name": "Interpret Cache config-usage"
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.cacheHit }}",
              "operation": "isTrue"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        1600,
        520
      ],
      "id": "2bd3a06d-e186-4e59-8e8d-dd07296aa6d9",
      "name": "If Cache Hit config-usage"
    },
    {
      "parameters": {
        "jsCode": "// Use cachedRecord for config-usage\nconst j = $json || {};\nconst rec = j.cachedRecord;\nlet findings = [];\nif (rec) {\n  if (Array.isArray(rec.findings)) findings = rec.findings;\n  else if (Array.isArray(rec)) findings = rec;\n  else if (typeof rec === 'object') findings = [rec];\n}\nreturn [{\n  json: {\n    ...j,\n    line: \"config-usage\",\n    cacheHit: true,\n    cacheMeta: rec && rec.meta ? rec.meta : undefined,\n    cacheSavedAt: rec && rec.savedAt ? rec.savedAt : undefined,\n    parseOk: j.cacheParseOk === true,\n    parseError: j.cacheError || \"\",\n    findings\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1800,
        480
      ],
      "id": "5fcfc685-11f7-4bf1-99bb-de905990ebf8",
      "name": "Use Cached config-usage"
    },
    {
      "parameters": {
        "jsCode": "const cfg = $json.scanConfig || {};\nconst lim = cfg.limits && cfg.limits.configUsage ? cfg.limits.configUsage : {};\nconst callLimit = lim.callLimit || 10;\nconst resourceSearchLimit = lim.resourceSearchLimit || 60;\nconst strSearchPerKey = lim.strSearchPerKey || 20;\nconst maxCodeConfirm = lim.maxCodeConfirm || 4;\nconst maxKeys = lim.maxKeys || 12;\n\nconst stage0 = $json.stage0Context || $node[\"Stage 0 Aggregate Context\"]?.json?.stage0Context || $node[\"Global Context Hub\"]?.json?.stage0Context || {};\nconst leakValues = Array.isArray(stage0.leakValues) ? stage0.leakValues : [];\nconst leakTypeNames = Array.isArray(stage0.leakTypeNames) ? stage0.leakTypeNames : [];\nconst ruleNames = Array.isArray(stage0.ruleNames) ? stage0.ruleNames : [];\nconst suspectTypes = Array.isArray(stage0.suspectTypes) ? stage0.suspectTypes : [];\n\nconst keys = new Set();\n\nfor (const v of leakValues) {\n  if (v && String(v).trim().length >= 4) keys.add(String(v).trim());\n}\n\nfor (const t of leakTypeNames) {\n  const s = String(t || '').toLowerCase();\n  if (!s) continue;\n  if (s.includes('pass')) { keys.add('password'); keys.add('passwd'); keys.add('pwd'); }\n  if (s.includes('token')) { keys.add('token'); keys.add('access_token'); keys.add('refresh_token'); }\n  if (s.includes('secret')) { keys.add('secret'); keys.add('secretKey'); keys.add('secret_key'); }\n  if (s.includes('key')) { keys.add('accessKey'); keys.add('access_key'); keys.add('apiKey'); keys.add('api_key'); }\n  if (s.includes('jwt')) { keys.add('jwt'); }\n}\n\nfor (const t of suspectTypes) {\n  const s = String(t || '').toLowerCase();\n  if (s.includes('sql')) { keys.add('jdbc'); keys.add('datasource'); keys.add('db.url'); keys.add('db.username'); keys.add('db.password'); }\n  if (s.includes('ssrf')) { keys.add('url'); keys.add('endpoint'); keys.add('proxy'); }\n  if (s.includes('deserial')) { keys.add('serialize'); keys.add('hessian'); keys.add('xstream'); }\n  if (s.includes('jndi')) { keys.add('jndi'); keys.add('ldap'); }\n  if (s.includes('file')) { keys.add('path'); keys.add('file'); keys.add('dir'); }\n}\n\nfor (const r of ruleNames) {\n  const s = String(r || '').toLowerCase();\n  if (!s) continue;\n  if (s.includes('jwt')) keys.add('jwt');\n  if (s.includes('token')) keys.add('token');\n  if (s.includes('oss') || s.includes('s3')) { keys.add('accessKey'); keys.add('secretKey'); keys.add('bucket'); }\n}\n\nconst keywordList = Array.from(keys).filter(Boolean).slice(0, maxKeys);\n\nconst chatInput = `\nYou are running **config-usage** (connect config/leaks to code usage).\nGoal: connect possible config keys/secrets to code usage points and output JSON findings.\n\nKeywords (max ${maxKeys}):\n${JSON.stringify(keywordList)}\n\nIf keywords is empty, return [].\n\nSteps (strict limits):\n1) For each keyword, call search_resources(query, limit=${resourceSearchLimit}).\n2) For each keyword, call get_methods_by_str_batch(items=[{str,limit}...], limit=${strSearchPerKey}).\n3) Optional: confirm top hits with get_code_cfr (<= ${maxCodeConfirm}).\n\nOutput requirements:\n- JSON array only, no explanation, [] if none\n- each finding must include line/type/severity/confidence/score/reason/trace\n- type = \"config_usage\" (or a more specific type if confirmed)\n- trace must include at least one usage method; put resource paths in evidence\n`;\n\nreturn [{ json: { ...$json, line: \"config-usage\", callLimit, chatInput, configUsageKeywords: keywordList } }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1800,
        620
      ],
      "id": "6bc2c530-2d04-4557-b276-ecd63380ce61",
      "name": "Build Prompt config-usage"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.chatInput }}",
        "options": {
          "systemMessage": "???? Java ??????????????????????????\n?????\n1) ????????? MCP ????????????????\n2) ???????????????/limit/compact/totalLimit ???\n3) ??? JSON ???????????? Markdown????????????????? []?\n4) findings ???????????\n   - line (string)\n   - type (string)\n   - severity (\"high\"|\"medium\"|\"low\")\n   - confidence (\"high\"|\"medium\"|\"low\")\n   - score (1-10 ??)\n   - reason (string, ????????????)\n   - trace (array, ???? {\"class\",\"method\",\"desc\"}?desc ??????)\n???? evidence/metadata ????????????????",
          "maxIterations": "={{ $json.callLimit }}"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 1.7,
      "position": [
        2100,
        620
      ],
      "id": "87527624-a2ad-45c6-9382-884670f9c09f",
      "name": "Agent config-usage"
    },
    {
      "parameters": {
        "jsCode": "// Parse AI Agent output into {line, findings[]} while preserving context fields (e.g., cacheKey/projectKey).\nconst ctx = $json || {};\nconst line = ctx.line || (ctx.context && ctx.context.line) || \"unknown\";\n\nfunction extractText(v) {\n  if (v === null || v === undefined) return \"\";\n  if (typeof v === \"string\") return v;\n  try { return JSON.stringify(v); } catch (e) { return String(v); }\n}\n\nlet raw = ctx.output ?? ctx.text ?? ctx.data ?? ctx;\nlet s = extractText(raw).trim();\n\n// Strip markdown fences if present\nconst fence = s.match(/```json\\s*([\\s\\S]*?)```/i);\nif (fence && fence[1]) s = fence[1].trim();\n\nlet findings = [];\nlet parseOk = false;\nlet parseError = \"\";\n\nif (!s) {\n  parseError = \"empty_response\";\n} else {\n  try {\n    const obj = JSON.parse(s);\n    if (Array.isArray(obj)) {\n      findings = obj;\n      parseOk = true;\n    } else if (obj && typeof obj === \"object\") {\n      if (Array.isArray(obj.findings)) {\n        findings = obj.findings;\n        parseOk = true;\n      } else if (Array.isArray(obj.data)) {\n        findings = obj.data;\n        parseOk = true;\n      } else {\n        parseError = \"json_object_without_findings_array\";\n      }\n    } else {\n      parseError = \"json_not_array\";\n    }\n  } catch (e) {\n    parseError = e.message || String(e);\n  }\n}\n\nreturn [{\n  json: {\n    ...ctx,\n    line,\n    parseOk,\n    parseError,\n    findings: Array.isArray(findings) ? findings : []\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2400,
        620
      ],
      "id": "5da212da-d981-4bb6-9c2d-673b289616b8",
      "name": "Parse config-usage"
    },
    {
      "parameters": {
        "jsCode": "// Prepare cacheValue JSON for config-usage\nconst j = $json || {};\nif (j.parseOk !== true) {\n  return [];\n}\nconst cacheValue = JSON.stringify({\n  line: \"config-usage\",\n  savedAt: new Date().toISOString(),\n  meta: {\n    projectKey: j.projectKey,\n    strategyVersion: j.strategyVersion,\n    scanConfigHash: j.scanConfigHash,\n    rulesHash: j.rulesHash,\n    filterHash: j.filterHash\n  },\n  findings: Array.isArray(j.findings) ? j.findings : []\n});\nreturn [{\n  json: {\n    ...j,\n    cacheValue\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2600,
        620
      ],
      "id": "c5e6bdca-c672-4b9b-a873-6c6d8a19f610",
      "name": "Prepare Cache Value config-usage"
    },
    {
      "parameters": {
        "operation": "set",
        "key": "={{ $json.cacheKey }}",
        "value": "={{ $json.cacheValue }}",
        "keyType": "string",
        "expire": true,
        "ttl": "={{ $json.cacheTtlSeconds }}"
      },
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [
        2800,
        620
      ],
      "id": "b6a58d08-a9a9-486c-98fe-14e8b510a231",
      "name": "Redis SET config-usage",
      "continueOnFail": true,
      "retryOnFail": true,
      "maxTries": 2,
      "waitBetweenTries": 500,
      "credentials": {
        "redis": {
          "id": "REPLACE_WITH_YOUR_REDIS_CREDENTIAL_ID",
          "name": "Redis account"
        }
      },
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "jsCode": "// Build configUsageContext from config-usage findings\nconst j = $json || {};\nconst findings = Array.isArray(j.findings) ? j.findings : [];\n\nfunction normStr(v) {\n  if (v === null || v === undefined) return '';\n  return String(v).trim();\n}\n\nfunction maskVal(v) {\n  const s = normStr(v);\n  if (!s) return '';\n  if (s.length <= 8) return s[0] + '***';\n  return s.slice(0,4) + '***' + s.slice(-4);\n}\n\nconst keys = new Set();\nconst values = new Set();\nconst methods = new Set();\nconst resources = new Set();\n\nfor (const f of findings) {\n  const ev = f && typeof f === 'object' ? (f.evidence || {}) : {};\n  const kw = normStr(ev.keyword || ev.key || ev.name);\n  if (kw) keys.add(kw);\n  const val = maskVal(ev.value);\n  if (val) values.add(val);\n  const path = normStr(ev.path || ev.resourcePath || ev.file);\n  if (path) resources.add(path);\n\n  const tr = Array.isArray(f.trace) ? f.trace : [];\n  for (const t of tr) {\n    const cls = normStr(t.class || t.className);\n    const m = normStr(t.method || t.methodName);\n    const id = [cls, m].filter(Boolean).join('#');\n    if (id) methods.add(id);\n  }\n}\n\nconst ctx = {\n  keys: Array.from(keys).slice(0, 50),\n  values: Array.from(values).slice(0, 20),\n  methods: Array.from(methods).slice(0, 50),\n  resources: Array.from(resources).slice(0, 50)\n};\n\nreturn [{ json: { line: 'config-usage-context', configUsageContext: ctx } }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2600,
        520
      ],
      "id": "748b66e6-afd8-44ae-8c25-0c3e727b9bc2",
      "name": "Config Usage Context"
    },
    {
      "parameters": {
        "jsCode": "// Merge stage0Context + configUsageContext, wait until both are ready\nconst data = $getWorkflowStaticData('node');\nconst execId = $execution?.id || 'unknown';\n\ndata.global = data.global || {};\nconst state = data.global[execId] || { stage0: null, config: null, doneStage0: false, doneConfig: false };\n\nif ($json && $json.stage0Context) {\n  state.stage0 = $json;\n  state.doneStage0 = true;\n  const ctx = $json.stage0Context || {};\n  const needConfig = (Array.isArray(ctx.leakValues) && ctx.leakValues.length) ||\n                     (Array.isArray(ctx.leakTypeNames) && ctx.leakTypeNames.length) ||\n                     (Array.isArray(ctx.ruleNames) && ctx.ruleNames.length) ||\n                     (Array.isArray(ctx.suspectTypes) && ctx.suspectTypes.length);\n  if (!needConfig) state.doneConfig = true;\n}\n\nif ($json && $json.configUsageContext) {\n  state.config = $json.configUsageContext;\n  state.doneConfig = true;\n}\n\nif (state.doneStage0 && state.doneConfig) {\n  const out = {\n    ...state.stage0,\n    configUsageContext: state.config || { keys: [], values: [], methods: [], resources: [] }\n  };\n  delete data.global[execId];\n  return [{ json: out }];\n}\n\ndata.global[execId] = state;\nreturn [];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        600,
        -420
      ],
      "id": "824263a3-1808-4b51-a6ca-8b3870ce7c51",
      "name": "Global Context Hub"
    }
  ],
  "connections": {
    "Start Workflow": {
      "main": [
        [
          {
            "node": "Global Constants",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Global Constants": {
      "main": [
        [
          {
            "node": "Get Jars List",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Jars List": {
      "main": [
        [
          {
            "node": "Compute Project Key",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Compute Project Key": {
      "main": [
        [
          {
            "node": "Init Scan Config",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Init Scan Config": {
      "main": [
        [
          {
            "node": "If Enable vul-rules",
            "type": "main",
            "index": 0
          },
          {
            "node": "If Enable sca-leak",
            "type": "main",
            "index": 0
          },
          {
            "node": "Stage A Reset Context",
            "type": "main",
            "index": 0
          },
          {
            "node": "Stage 0 Reset Context",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Cache Key audit-fast": {
      "main": [
        [
          {
            "node": "Redis GET audit-fast",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Redis GET audit-fast": {
      "main": [
        [
          {
            "node": "Interpret Cache audit-fast",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Interpret Cache audit-fast": {
      "main": [
        [
          {
            "node": "If Cache Hit audit-fast",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If Cache Hit audit-fast": {
      "main": [
        [
          {
            "node": "Use Cached audit-fast",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "AuditFast Get All Servlet",
            "type": "main",
            "index": 0
          },
          {
            "node": "AuditFast Get All Filter",
            "type": "main",
            "index": 0
          },
          {
            "node": "AuditFast Get All Listener",
            "type": "main",
            "index": 0
          },
          {
            "node": "AuditFast Get All Spring Controller",
            "type": "main",
            "index": 0
          },
          {
            "node": "AuditFast Get All Spring Interceptor",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Use Cached audit-fast": {
      "main": [
        [
          {
            "node": "Merge Lines",
            "type": "main",
            "index": 0
          },
          {
            "node": "Stage A Aggregate Context",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Prompt audit-fast": {
      "main": [
        [
          {
            "node": "Agent audit-fast",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Agent audit-fast": {
      "main": [
        [
          {
            "node": "Parse audit-fast",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse audit-fast": {
      "main": [
        [
          {
            "node": "AuditFast Aggregate Findings",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Parse Error Tap",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Cache Value audit-fast": {
      "main": [
        [
          {
            "node": "Redis SET audit-fast",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Cache Key graph-lite": {
      "main": [
        [
          {
            "node": "Redis GET graph-lite",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Redis GET graph-lite": {
      "main": [
        [
          {
            "node": "Interpret Cache graph-lite",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Interpret Cache graph-lite": {
      "main": [
        [
          {
            "node": "If Cache Hit graph-lite",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If Cache Hit graph-lite": {
      "main": [
        [
          {
            "node": "Use Cached graph-lite",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Build Prompt graph-lite",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Use Cached graph-lite": {
      "main": [
        [
          {
            "node": "Merge Lines",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Build Prompt graph-lite": {
      "main": [
        [
          {
            "node": "Agent graph-lite",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Agent graph-lite": {
      "main": [
        [
          {
            "node": "Parse graph-lite",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse graph-lite": {
      "main": [
        [
          {
            "node": "Merge Lines",
            "type": "main",
            "index": 1
          },
          {
            "node": "Prepare Cache Value graph-lite",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Parse Error Tap",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Cache Value graph-lite": {
      "main": [
        [
          {
            "node": "Redis SET graph-lite",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Cache Key vul-rules": {
      "main": [
        [
          {
            "node": "Redis GET vul-rules",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Redis GET vul-rules": {
      "main": [
        [
          {
            "node": "Interpret Cache vul-rules",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Interpret Cache vul-rules": {
      "main": [
        [
          {
            "node": "If Cache Hit vul-rules",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If Cache Hit vul-rules": {
      "main": [
        [
          {
            "node": "Use Cached vul-rules",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Build Prompt vul-rules",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Use Cached vul-rules": {
      "main": [
        [
          {
            "node": "Merge Lines",
            "type": "main",
            "index": 2
          },
          {
            "node": "Stage A Aggregate Context",
            "type": "main",
            "index": 0
          },
          {
            "node": "Stage 0 Aggregate Context",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Prompt vul-rules": {
      "main": [
        [
          {
            "node": "Agent vul-rules",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Agent vul-rules": {
      "main": [
        [
          {
            "node": "Parse vul-rules",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse vul-rules": {
      "main": [
        [
          {
            "node": "Merge Lines",
            "type": "main",
            "index": 2
          },
          {
            "node": "Prepare Cache Value vul-rules",
            "type": "main",
            "index": 0
          },
          {
            "node": "Stage A Aggregate Context",
            "type": "main",
            "index": 0
          },
          {
            "node": "Stage 0 Aggregate Context",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Parse Error Tap",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Cache Value vul-rules": {
      "main": [
        [
          {
            "node": "Redis SET vul-rules",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Cache Key sca-leak": {
      "main": [
        [
          {
            "node": "Redis GET sca-leak",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Redis GET sca-leak": {
      "main": [
        [
          {
            "node": "Interpret Cache sca-leak",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Interpret Cache sca-leak": {
      "main": [
        [
          {
            "node": "If Cache Hit sca-leak",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If Cache Hit sca-leak": {
      "main": [
        [
          {
            "node": "Use Cached sca-leak",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Build Prompt sca-leak",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Use Cached sca-leak": {
      "main": [
        [
          {
            "node": "Merge Lines",
            "type": "main",
            "index": 3
          },
          {
            "node": "Stage A Aggregate Context",
            "type": "main",
            "index": 0
          },
          {
            "node": "Stage 0 Aggregate Context",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Prompt sca-leak": {
      "main": [
        [
          {
            "node": "Agent sca-leak",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Agent sca-leak": {
      "main": [
        [
          {
            "node": "Parse sca-leak",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse sca-leak": {
      "main": [
        [
          {
            "node": "Merge Lines",
            "type": "main",
            "index": 3
          },
          {
            "node": "Prepare Cache Value sca-leak",
            "type": "main",
            "index": 0
          },
          {
            "node": "Stage A Aggregate Context",
            "type": "main",
            "index": 0
          },
          {
            "node": "Stage 0 Aggregate Context",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Parse Error Tap",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Cache Value sca-leak": {
      "main": [
        [
          {
            "node": "Redis SET sca-leak",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If Enable dfs-taint": {
      "main": [
        [
          {
            "node": "Build Cache Key dfs-taint",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "DFS Disabled",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "DFS Disabled": {
      "main": [
        [
          {
            "node": "Merge Lines",
            "type": "main",
            "index": 4
          }
        ]
      ]
    },
    "Build Cache Key dfs-taint": {
      "main": [
        [
          {
            "node": "Redis GET dfs-taint",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Redis GET dfs-taint": {
      "main": [
        [
          {
            "node": "Interpret Cache dfs-taint",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Interpret Cache dfs-taint": {
      "main": [
        [
          {
            "node": "If Cache Hit dfs-taint",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If Cache Hit dfs-taint": {
      "main": [
        [
          {
            "node": "Use Cached dfs-taint",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Get Sink Candidates dfs-taint",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Sink Candidates dfs-taint": {
      "main": [
        [
          {
            "node": "Apply Sink Candidates dfs-taint",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Apply Sink Candidates dfs-taint": {
      "main": [
        [
          {
            "node": "Build Prompt dfs-taint",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Use Cached dfs-taint": {
      "main": [
        [
          {
            "node": "Merge Lines",
            "type": "main",
            "index": 4
          }
        ]
      ]
    },
    "Build Prompt dfs-taint": {
      "main": [
        [
          {
            "node": "Agent dfs-taint",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Agent dfs-taint": {
      "main": [
        [
          {
            "node": "Parse dfs-taint",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse dfs-taint": {
      "main": [
        [
          {
            "node": "Merge Lines",
            "type": "main",
            "index": 4
          },
          {
            "node": "Prepare Cache Value dfs-taint",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Parse Error Tap",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Cache Value dfs-taint": {
      "main": [
        [
          {
            "node": "Redis SET dfs-taint",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Lines": {
      "main": [
        [
          {
            "node": "Collect Normalize Dedup",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Collect Normalize Dedup": {
      "main": [
        [
          {
            "node": "Loop Findings",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Loop Findings": {
      "main": [
        [
          {
            "node": "Rate Limit",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Done",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Rate Limit": {
      "main": [
        [
          {
            "node": "Build Report Prompt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Report Prompt": {
      "main": [
        [
          {
            "node": "Reporter Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Reporter Agent": {
      "main": [
        [
          {
            "node": "Loop Findings",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "LLM": {
      "ai_languageModel": [
        [
          {
            "node": "Agent audit-fast",
            "type": "ai_languageModel",
            "index": 0
          },
          {
            "node": "Agent graph-lite",
            "type": "ai_languageModel",
            "index": 0
          },
          {
            "node": "Agent vul-rules",
            "type": "ai_languageModel",
            "index": 0
          },
          {
            "node": "Agent sca-leak",
            "type": "ai_languageModel",
            "index": 0
          },
          {
            "node": "Agent dfs-taint",
            "type": "ai_languageModel",
            "index": 0
          },
          {
            "node": "Reporter Agent",
            "type": "ai_languageModel",
            "index": 0
          },
          {
            "node": "Agent config-usage",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "MCP audit-fast": {
      "ai_tool": [
        [
          {
            "node": "Agent audit-fast",
            "type": "ai_tool",
            "index": 0
          },
          {
            "node": "Agent config-usage",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "MCP graph-lite": {
      "ai_tool": [
        [
          {
            "node": "Agent graph-lite",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "MCP vul-rules": {
      "ai_tool": [
        [
          {
            "node": "Agent vul-rules",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "MCP sca-leak": {
      "ai_tool": [
        [
          {
            "node": "Agent sca-leak",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "MCP dfs-taint": {
      "ai_tool": [
        [
          {
            "node": "Agent dfs-taint",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "MCP report": {
      "ai_tool": [
        [
          {
            "node": "Reporter Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "If Enable graph-lite": {
      "main": [
        [
          {
            "node": "Build Cache Key graph-lite",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Graph-lite Disabled",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If Enable vul-rules": {
      "main": [
        [
          {
            "node": "Build Cache Key vul-rules",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Vul-rules Disabled",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If Enable sca-leak": {
      "main": [
        [
          {
            "node": "Build Cache Key sca-leak",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Sca-leak Disabled",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Graph-lite Disabled": {
      "main": [
        [
          {
            "node": "Merge Lines",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Vul-rules Disabled": {
      "main": [
        [
          {
            "node": "Merge Lines",
            "type": "main",
            "index": 2
          }
        ]
      ]
    },
    "Sca-leak Disabled": {
      "main": [
        [
          {
            "node": "Merge Lines",
            "type": "main",
            "index": 3
          }
        ]
      ]
    },
    "AuditFast Get All Servlet": {
      "main": [
        [
          {
            "node": "AuditFast Tag Servlet",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AuditFast Get All Filter": {
      "main": [
        [
          {
            "node": "AuditFast Tag Filter",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AuditFast Get All Listener": {
      "main": [
        [
          {
            "node": "AuditFast Tag Listener",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AuditFast Get All Spring Controller": {
      "main": [
        [
          {
            "node": "AuditFast Tag Spring Controller",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AuditFast Get All Spring Interceptor": {
      "main": [
        [
          {
            "node": "AuditFast Tag Spring Interceptor",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AuditFast Tag Servlet": {
      "main": [
        [
          {
            "node": "AuditFast Merge Entrypoints",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AuditFast Tag Filter": {
      "main": [
        [
          {
            "node": "AuditFast Merge Entrypoints",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "AuditFast Tag Listener": {
      "main": [
        [
          {
            "node": "AuditFast Merge Entrypoints",
            "type": "main",
            "index": 2
          }
        ]
      ]
    },
    "AuditFast Tag Spring Controller": {
      "main": [
        [
          {
            "node": "AuditFast Merge Entrypoints",
            "type": "main",
            "index": 3
          }
        ]
      ]
    },
    "AuditFast Tag Spring Interceptor": {
      "main": [
        [
          {
            "node": "AuditFast Merge Entrypoints",
            "type": "main",
            "index": 4
          }
        ]
      ]
    },
    "AuditFast Merge Entrypoints": {
      "main": [
        [
          {
            "node": "AuditFast Dedup Entrypoints",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AuditFast Dedup Entrypoints": {
      "main": [
        [
          {
            "node": "AuditFast Has Entrypoints",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AuditFast Get Class Info": {
      "main": [
        [
          {
            "node": "AuditFast Get Methods",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AuditFast Get Methods": {
      "main": [
        [
          {
            "node": "AuditFast Collect Methods",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AuditFast If Controller": {
      "main": [
        [
          {
            "node": "AuditFast Get Mappings",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "AuditFast No Mappings",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AuditFast Get Mappings": {
      "main": [
        [
          {
            "node": "AuditFast Normalize Mappings",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AuditFast Collect Methods": {
      "main": [
        [
          {
            "node": "AuditFast Merge Context",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AuditFast Normalize Mappings": {
      "main": [
        [
          {
            "node": "AuditFast Merge Context",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "AuditFast No Mappings": {
      "main": [
        [
          {
            "node": "AuditFast Merge Context",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "AuditFast Merge Context": {
      "main": [
        [
          {
            "node": "AuditFast Combine Context",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AuditFast Aggregate Findings": {
      "main": [
        [
          {
            "node": "AuditFast Loop Entrypoints",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AuditFast Combine Context": {
      "main": [
        [
          {
            "node": "Build Prompt audit-fast",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AuditFast Loop Entrypoints": {
      "main": [
        [
          {
            "node": "AuditFast Rate Limit",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "AuditFast Flush Findings",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AuditFast Rate Limit": {
      "main": [
        [
          {
            "node": "AuditFast Get Class Info",
            "type": "main",
            "index": 0
          },
          {
            "node": "AuditFast If Controller",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AuditFast Flush Findings": {
      "main": [
        [
          {
            "node": "Merge Lines",
            "type": "main",
            "index": 0
          },
          {
            "node": "Prepare Cache Value audit-fast",
            "type": "main",
            "index": 0
          },
          {
            "node": "Stage A Aggregate Context",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AuditFast Reset Accumulator": {
      "main": [
        [
          {
            "node": "AuditFast Loop Entrypoints",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AuditFast Has Entrypoints": {
      "main": [
        [
          {
            "node": "AuditFast Reset Accumulator",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "AuditFast No Entrypoints",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AuditFast No Entrypoints": {
      "main": [
        [
          {
            "node": "Merge Lines",
            "type": "main",
            "index": 0
          },
          {
            "node": "Prepare Cache Value audit-fast",
            "type": "main",
            "index": 0
          },
          {
            "node": "Stage A Aggregate Context",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Error Tap": {
      "main": [
        [
          {
            "node": "Parse Errors To Findings",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Errors To Findings": {
      "main": [
        [
          {
            "node": "Merge Lines",
            "type": "main",
            "index": 5
          }
        ]
      ]
    },
    "Stage A Aggregate Context": {
      "main": [
        [
          {
            "node": "If Enable graph-lite",
            "type": "main",
            "index": 0
          },
          {
            "node": "If Enable dfs-taint",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Stage 0 Reset Context": {
      "main": [
        [
          {
            "node": "Stage 0 Aggregate Context",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Stage 0 Aggregate Context": {
      "main": [
        [
          {
            "node": "Build Cache Key config-usage",
            "type": "main",
            "index": 0
          },
          {
            "node": "Global Context Hub",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Cache Key config-usage": {
      "main": [
        [
          {
            "node": "Redis GET config-usage",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Redis GET config-usage": {
      "main": [
        [
          {
            "node": "Interpret Cache config-usage",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Interpret Cache config-usage": {
      "main": [
        [
          {
            "node": "If Cache Hit config-usage",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If Cache Hit config-usage": {
      "main": [
        [
          {
            "node": "Use Cached config-usage",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Build Prompt config-usage",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Prompt config-usage": {
      "main": [
        [
          {
            "node": "Agent config-usage",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Agent config-usage": {
      "main": [
        [
          {
            "node": "Parse config-usage",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse config-usage": {
      "main": [
        [
          {
            "node": "Prepare Cache Value config-usage",
            "type": "main",
            "index": 0
          },
          {
            "node": "Config Usage Context",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Parse Error Tap",
            "type": "main",
            "index": 0
          }
        ],
        [],
        [],
        [],
        [],
        [
          {
            "node": "Merge Lines",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Cache Value config-usage": {
      "main": [
        [
          {
            "node": "Redis SET config-usage",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Use Cached config-usage": {
      "main": [
        [
          {
            "node": "Config Usage Context",
            "type": "main",
            "index": 0
          }
        ],
        [],
        [],
        [],
        [],
        [],
        [
          {
            "node": "Merge Lines",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Config Usage Context": {
      "main": [
        [
          {
            "node": "Global Context Hub",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Global Context Hub": {
      "main": [
        [
          {
            "node": "Build Cache Key audit-fast",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "8acd1db4-8a6e-4210-9790-e4f83a005817",
  "meta": {
    "instanceId": "REPLACE_WITH_YOUR_INSTANCE_ID"
  },
  "id": "REPLACE_WITH_YOUR_WORKFLOW_ID",
  "tags": [],
  "pinData": {}
}