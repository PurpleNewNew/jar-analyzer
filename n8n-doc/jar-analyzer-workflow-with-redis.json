{
  "name": "jar-analyzer-workflow-with-redis",
  "nodes": [
    {
      "parameters": {},
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [
        0,
        0
      ],
      "id": "389d6683-84ad-46c4-9b49-afda4a133f92",
      "name": "Start Workflow"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-globals.globalConstants",
      "typeVersion": 1,
      "position": [
        200,
        0
      ],
      "id": "05a64e41-2189-4f16-bfdf-9bb2db628016",
      "name": "Global Constants",
      "credentials": {
        "globalConstantsApi": {
          "id": "IH7D2VRyHX4WOTgN",
          "name": "Global Constants account"
        }
      }
    },
    {
      "parameters": {
        "url": "={{ $('Global Constants').first().json.constants['jar-analyzer-api'] }}api/get_jars_list",
        "options": {
          "headers": {
            "Token": "={{ $('Global Constants').first().json.constants['jar-analyzer-api-token'] || '' }}"
          }
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        400,
        0
      ],
      "id": "ad620021-38b9-4d0a-84e6-d7655715ef1a",
      "name": "Get Jars List"
    },
    {
      "parameters": {
        "jsCode": "// Compute a stable projectKey (sha1) from jar list for Redis cache namespacing.\n// Input: /api/get_jars_list response (JSON array of jar paths).\nconst crypto = require('crypto');\n\nlet jars = [];\nfor (const it of $input.all()) {\n  const j = it.json;\n  if (Array.isArray(j)) jars.push(...j);\n  else if (Array.isArray(j?.jars)) jars.push(...j.jars);\n  else if (Array.isArray(j?.data)) jars.push(...j.data);\n}\n\njars = jars\n  .filter(x => typeof x === 'string')\n  .map(s => s.trim())\n  .filter(Boolean);\n\nconst jarsOriginal = jars.slice();\nconst jarsSorted = jars.slice().sort();\nconst payload = jarsSorted.join('\\n');\n\n// Strategy version: bump this string whenever you change workflow logic to invalidate old cache\nconst strategyVersion = '5lines-v1';\n\n// Default TTL: 7 days\nconst cacheTtlSeconds = 7 * 24 * 60 * 60;\n\nconst projectKey = crypto.createHash('sha1').update(payload).digest('hex');\n\nreturn [{\n  json: {\n    jars: jarsSorted,\n    jarsOriginal,\n    jarsSorted,\n    jarCount: jarsOriginal.length,\n    projectKey,\n    strategyVersion,\n    cacheTtlSeconds\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        600,
        0
      ],
      "id": "bcd68895-2a29-4b13-8c4d-82ccafc88d99",
      "name": "Compute Project Key"
    },
    {
      "parameters": {
        "jsCode": "// Initialize scan config for 5-line audit workflow (Redis version).\nconst jars = Array.isArray($json.jars) ? $json.jars : [];\nconst jarCount = typeof $json.jarCount === 'number' ? $json.jarCount : jars.length;\n\n// Prefer original jar ordering (if available) for gadgetDir heuristic\nconst jarsForGadget = Array.isArray($json.jarsOriginal) && $json.jarsOriginal.length\n  ? $json.jarsOriginal\n  : jars;\n\n// Heuristic: derive a default gadgetDir from the first jar path\nlet gadgetDir = '';\nif (jarsForGadget.length > 0) {\n  const first = jarsForGadget[0];\n  const idx = Math.max(first.lastIndexOf('/'), first.lastIndexOf('\\\\'));\n  if (idx > 0) gadgetDir = first.slice(0, idx);\n}\n\nconst scanConfig = {\n  enableDfsTaint: false,\n  scope: 'app',\n  excludeJdk: true,\n  limits: {\n    auditFast: { callLimit: 14, mappingSampleLimit: 120, resourceSearchLimit: 80, strSearchPerKeyword: 20, maxCodeConfirm: 6 },\n    graphLite: { callLimit: 16, sinkPerTypeLimit: 20, maxDepth: 4, maxChains: 60 },\n    vulRules: { callLimit: 10, levels: ['high','medium'], groupBy: 'rule', perRuleLimit: 15, totalLimit: 160 },\n    scaLeak: { callLimit: 10, enableSca: true, enableLeak: true, enableGadget: false, gadgetDir: gadgetDir, leakLimit: 120 },\n    dfsTaint: { callLimit: 28, sinkNames: ['Runtime.exec(String)','ProcessBuilder.start','InitialContext.lookup','URL.openConnection'], depth: 10, maxLimit: 80, maxPaths: 80, timeoutMs: 90000, onlyFromWeb: true, resultLimit: 120, compact: true }\n  }\n};\n\nreturn [{\n  json: {\n    ...$json,\n    jars,\n    jarCount,\n    scanConfig\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        800,
        0
      ],
      "id": "b5c56f72-40f4-4fa6-9f68-c27a61e9d614",
      "name": "Init Scan Config"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "glm-4.6",
          "mode": "list",
          "cachedResultName": "GLM-4.6"
        },
        "options": {
          "thinking": true
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatAnthropic",
      "typeVersion": 1.3,
      "position": [
        800,
        -500
      ],
      "id": "8b9afc54-1e6b-4ee1-9391-6d920975dfa1",
      "name": "LLM",
      "credentials": {
        "anthropicApi": {
          "id": "TaNxIU4TnOE9TUHI",
          "name": "Anthropic account"
        }
      }
    },
    {
      "parameters": {
        "sseEndpoint": "={{ $('Global Constants').first().json.constants['jar-analyzer-mcp-audit-fast'] }}sse",
        "authentication": "headerAuth",
        "headerParameters": {
          "parameters": [
            {
              "name": "Token",
              "value": "={{ $('Global Constants').first().json.constants['jar-analyzer-mcp-token'] || '' }}"
            }
          ]
        }
      },
      "type": "@n8n/n8n-nodes-langchain.toolMcp",
      "typeVersion": 1.2,
      "position": [
        1000,
        -500
      ],
      "id": "a5d3f21a-16a1-40eb-b1f1-d6043b377f0a",
      "name": "MCP audit-fast"
    },
    {
      "parameters": {
        "sseEndpoint": "={{ $('Global Constants').first().json.constants['jar-analyzer-mcp-graph-lite'] }}sse",
        "authentication": "headerAuth",
        "headerParameters": {
          "parameters": [
            {
              "name": "Token",
              "value": "={{ $('Global Constants').first().json.constants['jar-analyzer-mcp-token'] || '' }}"
            }
          ]
        }
      },
      "type": "@n8n/n8n-nodes-langchain.toolMcp",
      "typeVersion": 1.2,
      "position": [
        1000,
        -430
      ],
      "id": "4ee9b1df-fc56-4092-b21e-f383e92a8831",
      "name": "MCP graph-lite"
    },
    {
      "parameters": {
        "sseEndpoint": "={{ $('Global Constants').first().json.constants['jar-analyzer-mcp-vul-rules'] }}sse",
        "authentication": "headerAuth",
        "headerParameters": {
          "parameters": [
            {
              "name": "Token",
              "value": "={{ $('Global Constants').first().json.constants['jar-analyzer-mcp-token'] || '' }}"
            }
          ]
        }
      },
      "type": "@n8n/n8n-nodes-langchain.toolMcp",
      "typeVersion": 1.2,
      "position": [
        1000,
        -360
      ],
      "id": "66cac3b1-072f-47f8-8774-5f566ae6577a",
      "name": "MCP vul-rules"
    },
    {
      "parameters": {
        "sseEndpoint": "={{ $('Global Constants').first().json.constants['jar-analyzer-mcp-sca-leak'] }}sse",
        "authentication": "headerAuth",
        "headerParameters": {
          "parameters": [
            {
              "name": "Token",
              "value": "={{ $('Global Constants').first().json.constants['jar-analyzer-mcp-token'] || '' }}"
            }
          ]
        }
      },
      "type": "@n8n/n8n-nodes-langchain.toolMcp",
      "typeVersion": 1.2,
      "position": [
        1000,
        -290
      ],
      "id": "3f391298-ece1-4ea8-b91b-e1adbd8a9e9b",
      "name": "MCP sca-leak"
    },
    {
      "parameters": {
        "sseEndpoint": "={{ $('Global Constants').first().json.constants['jar-analyzer-mcp-dfs-taint'] }}sse",
        "authentication": "headerAuth",
        "headerParameters": {
          "parameters": [
            {
              "name": "Token",
              "value": "={{ $('Global Constants').first().json.constants['jar-analyzer-mcp-token'] || '' }}"
            }
          ]
        }
      },
      "type": "@n8n/n8n-nodes-langchain.toolMcp",
      "typeVersion": 1.2,
      "position": [
        1000,
        -220
      ],
      "id": "531c6f73-ec94-480f-b682-52b9180d1263",
      "name": "MCP dfs-taint"
    },
    {
      "parameters": {
        "sseEndpoint": "={{ $('Global Constants').first().json.constants['report-service-mcp'] }}sse",
        "authentication": "headerAuth",
        "headerParameters": {
          "parameters": [
            {
              "name": "Token",
              "value": "={{ $('Global Constants').first().json.constants['report-service-mcp-token'] || '' }}"
            }
          ]
        }
      },
      "type": "@n8n/n8n-nodes-langchain.mcpClientTool",
      "typeVersion": 1.2,
      "position": [
        1000,
        520
      ],
      "id": "8796d45e-44ac-4443-825c-3a83f5e96dac",
      "name": "MCP report"
    },
    {
      "parameters": {
        "jsCode": "// Build Redis cacheKey for line: audit-fast\nconst strategyVersion = $json.strategyVersion || '5lines-v1';\nconst projectKey = $json.projectKey || 'unknown';\nconst cacheKey = `ja:5lines:${strategyVersion}:${projectKey}:audit-fast`;\n\nreturn [{\n  json: {\n    ...$json,\n    line: \"audit-fast\",\n    cacheKey\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1000,
        -300
      ],
      "id": "bc1a016b-b077-4197-8209-b7e5d43d4063",
      "name": "Build Cache Key audit-fast"
    },
    {
      "parameters": {
        "operation": "get",
        "key": "={{ $json.cacheKey }}",
        "options": {}
      },
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [
        1200,
        -300
      ],
      "id": "136c5919-74a0-430e-a642-270f2008a4e9",
      "name": "Redis GET audit-fast",
      "continueOnFail": true,
      "retryOnFail": true,
      "maxTries": 2,
      "waitBetweenTries": 500,
      "credentials": {
        "redis": {
          "id": "REPLACE_WITH_YOUR_REDIS_CREDENTIAL_ID",
          "name": "Redis account"
        }
      },
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "jsCode": "// Interpret Redis GET output and decide cacheHit.\n// Expected Redis node shape for GET: { value: <string|null> }.\n// We only inspect known value fields to avoid accidentally treating other context strings as cache values.\nconst j = $json || {};\n\nfunction getRedisValue(obj) {\n  if (!obj || typeof obj !== 'object') return null;\n\n  if (typeof obj.value === 'string' || obj.value === null) return obj.value;\n  if (typeof obj.data === 'string' || obj.data === null) return obj.data;\n  if (typeof obj.result === 'string' || obj.result === null) return obj.result;\n\n  // Some variants may nest under \"redis\"\n  if (obj.redis && typeof obj.redis === 'object') {\n    const r = obj.redis;\n    if (typeof r.value === 'string' || r.value === null) return r.value;\n    if (typeof r.data === 'string' || r.data === null) return r.data;\n    if (typeof r.result === 'string' || r.result === null) return r.result;\n  }\n\n  return null;\n}\n\nconst rawVal = getRedisValue(j);\nconst rawStr = (typeof rawVal === 'string') ? rawVal : '';\n\nlet cacheHit = false;\nlet cacheParseOk = false;\nlet cachedRecord = null;\nlet cacheError = null;\n\nif (rawStr && rawStr.trim().length > 0) {\n  try {\n    cachedRecord = JSON.parse(rawStr);\n    cacheParseOk = true;\n    cacheHit = true;\n  } catch (e) {\n    cacheError = `cache_json_parse_error: ${String(e)}`;\n  }\n}\n\nreturn {\n  json: {\n    ...j,\n    cacheHit,\n    cacheParseOk,\n    cacheError,\n    cachedRecord,\n    cacheValuePreview: rawStr.length > 500 ? rawStr.slice(0, 500) + '...(truncated)' : rawStr\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1400,
        -300
      ],
      "id": "8e533845-654c-4c94-a1d8-45c1c2b0ef90",
      "name": "Interpret Cache audit-fast"
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.cacheHit }}",
              "operation": "isTrue"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        1600,
        -300
      ],
      "id": "819f316b-2ad6-4bec-97a0-4da5f686daa6",
      "name": "If Cache Hit audit-fast"
    },
    {
      "parameters": {
        "jsCode": "// Use cachedRecord for audit-fast\nconst j = $json || {};\nconst rec = j.cachedRecord;\nlet findings = [];\nif (rec) {\n  if (Array.isArray(rec.findings)) findings = rec.findings;\n  else if (Array.isArray(rec)) findings = rec;\n  else if (typeof rec === 'object') findings = [rec];\n}\nreturn [{\n  json: {\n    ...j,\n    line: \"audit-fast\",\n    cacheHit: true,\n    parseOk: j.cacheParseOk === true,\n    parseError: j.cacheError || \"\",\n    findings\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1800,
        -360
      ],
      "id": "f073a115-b4a0-454f-8014-0c9cf7d6f4f6",
      "name": "Use Cached audit-fast"
    },
    {
      "parameters": {
        "jsCode": "const cfg = $json.scanConfig || {};\nconst lim = cfg.limits && cfg.limits.auditFast ? cfg.limits.auditFast : {};\nconst callLimit = lim.callLimit || 14;\n\nconst riskyPathHints = [\n  \"/actuator\",\"/swagger\",\"/api-docs\",\"/v2/api-docs\",\"/v3/api-docs\",\n  \"/h2-console\",\"/druid\",\"/jolokia\",\"/admin\",\"/debug\",\"/internal\",\n  \"/management\",\"/metrics\",\"/env\",\"/heapdump\",\"/threaddump\"\n];\n\nconst resourceQueries = [\n  \"management.endpoints\",\"actuator\",\"swagger\",\"api-docs\",\"spring.profiles.active\",\n  \"spring.datasource.password\",\"spring.datasource.username\",\n  \"accessKey\",\"secretKey\",\"AKIA\",\"BEGIN PRIVATE KEY\",\"jwt\",\"token\",\n  \"druid\",\"h2-console\",\"jolokia\",\"log4j2\",\"shiro\",\"rememberMe\",\"xxl.job\"\n];\n\nconst strKeywords = [\n  \"Runtime.getRuntime().exec\",\n  \"new ProcessBuilder\",\n  \"ScriptEngineManager\",\n  \"javax.naming.InitialContext\",\n  \"ObjectInputStream\",\n  \"XMLDecoder\",\n  \"org.yaml.snakeyaml.Yaml\",\n  \"com.alibaba.fastjson\",\n  \"XStream.fromXML\",\n  \"java.net.URL\",\n  \"openConnection(\",\n  \"HttpURLConnection\"\n];\n\nconst mappingSampleLimit = lim.mappingSampleLimit || 120;\nconst resourceSearchLimit = lim.resourceSearchLimit || 80;\nconst strSearchPerKeyword = lim.strSearchPerKeyword || 20;\nconst maxCodeConfirm = lim.maxCodeConfirm || 6;\n\nconst chatInput = `\n你正在执行 **audit-fast**（快线：入口/证据/资源）。仅使用本线 MCP 工具完成扫描，并输出 JSON findings 数组。\n\n执行步骤（务必控制规模）：\n1) 入口盘点（用于证据，不要把“盘点”本身当漏洞输出）：\n   - get_all_spring_controllers\n   - get_all_spring_interceptors\n   - get_all_servlets / get_all_filters / get_all_listeners\n2) Spring Mapping 快筛（只抽样前 ${mappingSampleLimit} 个 controller）：\n   - 对每个 controller 调用 get_spring_mappings(class)\n   - 只保留 path 命中以下敏感前缀的映射：${JSON.stringify(riskyPathHints)}\n   - 对命中的映射输出 findings（type=exposed_endpoint 或 insecure_management_endpoint）\n3) 资源证据快筛：\n   - 对每个 query 调用 search_resources(query, limit=${resourceSearchLimit})\n   - 如果命中配置项表明“管理端点暴露/调试模式/弱配置”，输出 findings（type=insecure_config 或 exposed_admin_surface）\n4) 危险 API 字符串快筛（批量）：\n   - 用 get_methods_by_str_batch(items=[{str,limit}...], limit=${strSearchPerKeyword}) 搜索：${JSON.stringify(strKeywords)}\n   - 对命中 count>0 的条目，挑选最可疑的方法（总计不超过 ${maxCodeConfirm} 个）用 get_code_cfr 获取片段确认\n   - 依据证据输出 findings（type=risky_api_usage / potential_rce_surface / potential_ssrf_surface / potential_deserialization）\n输出要求：\n- findings 中每条都要有 trace（至少 1 个方法：命中的 handler 或命中的方法）\n- 不要输出大段源码全文，只在 reason/evidence 中引用极短片段或关键调用点\n- 无发现输出 []\n`;\nreturn [{ json: { ...$json, line: \"audit-fast\", callLimit, chatInput } }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1800,
        -240
      ],
      "id": "eec319ce-5465-43d7-a899-576b22b2fcc4",
      "name": "Build Prompt audit-fast"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.chatInput }}",
        "options": {
          "systemMessage": "你是资深 Java 安全审计工程师，目标是做自动化安全审计（静态分析）。\n必须遵守：\n1) 只能使用当前可用的 MCP 工具获取事实证据；禁止凭空猜测。\n2) 严格控制输出规模：优先使用批量/limit/compact/totalLimit 参数。\n3) 只输出 JSON 数组（不要输出解释、不要 Markdown、不要代码块围栏）。没有发现则输出 []。\n4) findings 数组元素必须包含字段：\n   - line (string)\n   - type (string)\n   - severity (\"high\"|\"medium\"|\"low\")\n   - confidence (\"high\"|\"medium\"|\"low\")\n   - score (1-10 整数)\n   - reason (string, 简洁说明命中原因与证据点)\n   - trace (array, 每项包含 {\"class\",\"method\",\"desc\"}；desc 可为空字符串)\n可以附加 evidence/metadata 等字段，但不要输出大段源码全文。",
          "maxIterations": "={{ $json.callLimit }}"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2.2,
      "position": [
        2000,
        -240
      ],
      "id": "bdea7ddf-afe9-4311-9f4d-2deaf2b78c6c",
      "name": "Agent audit-fast",
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "jsCode": "// Parse AI Agent output into {line, findings[]} while preserving context fields (e.g., cacheKey/projectKey).\nconst ctx = $json || {};\nconst line = ctx.line || (ctx.context && ctx.context.line) || \"unknown\";\n\nfunction extractText(v) {\n  if (v === null || v === undefined) return \"\";\n  if (typeof v === \"string\") return v;\n  try { return JSON.stringify(v); } catch (e) { return String(v); }\n}\n\nlet raw = ctx.output ?? ctx.text ?? ctx.data ?? ctx;\nlet s = extractText(raw).trim();\n\n// Strip markdown fences if present\nconst fence = s.match(/```json\\s*([\\s\\S]*?)```/i);\nif (fence && fence[1]) s = fence[1].trim();\n\nlet findings = [];\nlet parseOk = false;\nlet parseError = \"\";\n\nif (!s) {\n  parseError = \"empty_response\";\n} else {\n  try {\n    const obj = JSON.parse(s);\n    if (Array.isArray(obj)) {\n      findings = obj;\n      parseOk = true;\n    } else if (obj && typeof obj === \"object\") {\n      if (Array.isArray(obj.findings)) {\n        findings = obj.findings;\n        parseOk = true;\n      } else if (Array.isArray(obj.data)) {\n        findings = obj.data;\n        parseOk = true;\n      } else {\n        parseError = \"json_object_without_findings_array\";\n      }\n    } else {\n      parseError = \"json_not_array\";\n    }\n  } catch (e) {\n    parseError = e.message || String(e);\n  }\n}\n\nif (!parseOk) {\n  throw new Error(`[${line}] parse failed: ${parseError}`);\n}\n\nreturn [{\n  json: {\n    ...ctx,\n    line,\n    parseOk,\n    parseError,\n    findings: Array.isArray(findings) ? findings : []\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2200,
        -240
      ],
      "id": "8826e6c2-5f90-4628-b963-59a38be0a07c",
      "name": "Parse audit-fast"
    },
    {
      "parameters": {
        "jsCode": "// Prepare cacheValue JSON for audit-fast\nconst j = $json || {};\nif (j.parseOk !== true) {\n  return [];\n}\nconst cacheValue = JSON.stringify({\n  line: \"audit-fast\",\n  savedAt: new Date().toISOString(),\n  findings: Array.isArray(j.findings) ? j.findings : []\n});\nreturn [{\n  json: {\n    ...j,\n    cacheValue\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2400,
        -240
      ],
      "id": "5b5bc274-d507-4717-bf49-88ba8d242277",
      "name": "Prepare Cache Value audit-fast"
    },
    {
      "parameters": {
        "operation": "set",
        "key": "={{ $json.cacheKey }}",
        "value": "={{ $json.cacheValue }}",
        "keyType": "string",
        "expire": true,
        "ttl": "={{ $json.cacheTtlSeconds }}"
      },
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [
        2600,
        -240
      ],
      "id": "83ea7823-c71c-4084-9e76-e64dff40aaf1",
      "name": "Redis SET audit-fast",
      "continueOnFail": true,
      "retryOnFail": true,
      "maxTries": 2,
      "waitBetweenTries": 500,
      "credentials": {
        "redis": {
          "id": "REPLACE_WITH_YOUR_REDIS_CREDENTIAL_ID",
          "name": "Redis account"
        }
      },
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "jsCode": "// Build Redis cacheKey for line: graph-lite\nconst strategyVersion = $json.strategyVersion || '5lines-v1';\nconst projectKey = $json.projectKey || 'unknown';\nconst cacheKey = `ja:5lines:${strategyVersion}:${projectKey}:graph-lite`;\n\nreturn [{\n  json: {\n    ...$json,\n    line: \"graph-lite\",\n    cacheKey\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1000,
        -120
      ],
      "id": "05eabef1-ee4e-4c43-a01e-6743ab9f0b38",
      "name": "Build Cache Key graph-lite"
    },
    {
      "parameters": {
        "operation": "get",
        "key": "={{ $json.cacheKey }}",
        "options": {}
      },
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [
        1200,
        -120
      ],
      "id": "25b40a6d-fb4b-4c0a-b2e9-04372d2f077d",
      "name": "Redis GET graph-lite",
      "continueOnFail": true,
      "retryOnFail": true,
      "maxTries": 2,
      "waitBetweenTries": 500,
      "credentials": {
        "redis": {
          "id": "REPLACE_WITH_YOUR_REDIS_CREDENTIAL_ID",
          "name": "Redis account"
        }
      },
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "jsCode": "// Interpret Redis GET output and decide cacheHit.\n// Expected Redis node shape for GET: { value: <string|null> }.\n// We only inspect known value fields to avoid accidentally treating other context strings as cache values.\nconst j = $json || {};\n\nfunction getRedisValue(obj) {\n  if (!obj || typeof obj !== 'object') return null;\n\n  if (typeof obj.value === 'string' || obj.value === null) return obj.value;\n  if (typeof obj.data === 'string' || obj.data === null) return obj.data;\n  if (typeof obj.result === 'string' || obj.result === null) return obj.result;\n\n  // Some variants may nest under \"redis\"\n  if (obj.redis && typeof obj.redis === 'object') {\n    const r = obj.redis;\n    if (typeof r.value === 'string' || r.value === null) return r.value;\n    if (typeof r.data === 'string' || r.data === null) return r.data;\n    if (typeof r.result === 'string' || r.result === null) return r.result;\n  }\n\n  return null;\n}\n\nconst rawVal = getRedisValue(j);\nconst rawStr = (typeof rawVal === 'string') ? rawVal : '';\n\nlet cacheHit = false;\nlet cacheParseOk = false;\nlet cachedRecord = null;\nlet cacheError = null;\n\nif (rawStr && rawStr.trim().length > 0) {\n  try {\n    cachedRecord = JSON.parse(rawStr);\n    cacheParseOk = true;\n    cacheHit = true;\n  } catch (e) {\n    cacheError = `cache_json_parse_error: ${String(e)}`;\n  }\n}\n\nreturn {\n  json: {\n    ...j,\n    cacheHit,\n    cacheParseOk,\n    cacheError,\n    cachedRecord,\n    cacheValuePreview: rawStr.length > 500 ? rawStr.slice(0, 500) + '...(truncated)' : rawStr\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1400,
        -120
      ],
      "id": "006d23ea-f281-4cba-94b0-e93cab8bbe4c",
      "name": "Interpret Cache graph-lite"
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.cacheHit }}",
              "operation": "isTrue"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        1600,
        -120
      ],
      "id": "8b44d5c1-61ae-4fd3-b2fc-8491f212498d",
      "name": "If Cache Hit graph-lite"
    },
    {
      "parameters": {
        "jsCode": "// Use cachedRecord for graph-lite\nconst j = $json || {};\nconst rec = j.cachedRecord;\nlet findings = [];\nif (rec) {\n  if (Array.isArray(rec.findings)) findings = rec.findings;\n  else if (Array.isArray(rec)) findings = rec;\n  else if (typeof rec === 'object') findings = [rec];\n}\nreturn [{\n  json: {\n    ...j,\n    line: \"graph-lite\",\n    cacheHit: true,\n    parseOk: j.cacheParseOk === true,\n    parseError: j.cacheError || \"\",\n    findings\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1800,
        -180
      ],
      "id": "2293fdbc-74bd-45c0-a3fc-6a9eda189825",
      "name": "Use Cached graph-lite"
    },
    {
      "parameters": {
        "jsCode": "const cfg = $json.scanConfig || {};\nconst lim = cfg.limits && cfg.limits.graphLite ? cfg.limits.graphLite : {};\nconst callLimit = lim.callLimit || 16;\n\nconst sinkNames = [\n  \"Runtime.exec(String)\",\n  \"ProcessBuilder.start\",\n  \"ScriptEngine.eval\",\n  \"InitialContext.lookup\",\n  \"Context.lookup\",\n  \"DirContext.search\",\n  \"LdapContext.search\",\n  \"Statement.executeQuery\",\n  \"Statement.executeUpdate\",\n  \"Connection.prepareStatement\",\n  \"ObjectInputStream.readObject\",\n  \"XMLDecoder.readObject\",\n  \"Yaml.load\",\n  \"JSON.parseObject\",\n  \"ObjectMapper.readValue\",\n  \"HessianInput.readObject\",\n  \"XStream.fromXML\",\n  \"URL.openConnection\",\n  \"HttpURLConnection.connect\",\n  \"FileInputStream.new\",\n  \"FileOutputStream.new\",\n  \"RandomAccessFile.new\",\n  \"File.delete\"\n];\n\nconst sinkPerTypeLimit = lim.sinkPerTypeLimit || 20;\nconst maxDepth = lim.maxDepth || 4;\nconst maxChains = lim.maxChains || 60;\n\nconst chatInput = `\n你正在执行 **graph-lite**（快线：调用图/方法索引，轻量回溯）。\n目标：从常见 Sink 出发，使用调用图向上回溯若干层，构造“潜在可达链路”，输出 JSON findings。\n\n执行策略（务必限流，避免爆炸）：\n1) 对以下 sinkName 逐个调用 get_callers_by_sink(sinkName, limit=${sinkPerTypeLimit})：\n   ${JSON.stringify(sinkNames)}\n2) 对每个 sink 的每个调用点（MethodResult）：\n   - 以该方法为起点，最多回溯 ${maxDepth} 层：\n     使用 get_callers(class, method, desc) 找上游调用者\n   - 每层最多保留 2~3 个最像业务代码的 caller（优先包名非 java/javax/sun，且类名包含 Controller/Service/Action/Servlet/Handler）\n   - 一旦发现疑似入口（例如方法名 doGet/doPost/service，或类名包含 Controller/Servlet），可提前停止\n3) 对每条链路输出 1 个 finding（最多 ${maxChains} 条）：\n   - type：根据 sinkName 粗略归类（command_exec/sql_injection/jndi_injection/deserialization/ssrf/file_io 等）\n   - confidence：如果链路起点疑似入口则 medium/high；否则 low/medium\n   - trace：从“疑似入口”到“调用点”再到“sink”三段（若无法确认入口，则 trace 以 callers 链 + sink 结束）\n注意：\n- 这是 graph-lite：只做“调用可达”粗回溯，不做参数污染确认，所以 reason 要明确“仅调用图可达，需 dfs/taint 复核”。\n- 无发现输出 []\n`;\nreturn [{ json: { ...$json, line: \"graph-lite\", callLimit, chatInput } }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1800,
        -60
      ],
      "id": "880b25c6-6463-4bc0-9e5c-3890b140076e",
      "name": "Build Prompt graph-lite"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.chatInput }}",
        "options": {
          "systemMessage": "你是资深 Java 安全审计工程师，目标是做自动化安全审计（静态分析）。\n必须遵守：\n1) 只能使用当前可用的 MCP 工具获取事实证据；禁止凭空猜测。\n2) 严格控制输出规模：优先使用批量/limit/compact/totalLimit 参数。\n3) 只输出 JSON 数组（不要输出解释、不要 Markdown、不要代码块围栏）。没有发现则输出 []。\n4) findings 数组元素必须包含字段：\n   - line (string)\n   - type (string)\n   - severity (\"high\"|\"medium\"|\"low\")\n   - confidence (\"high\"|\"medium\"|\"low\")\n   - score (1-10 整数)\n   - reason (string, 简洁说明命中原因与证据点)\n   - trace (array, 每项包含 {\"class\",\"method\",\"desc\"}；desc 可为空字符串)\n可以附加 evidence/metadata 等字段，但不要输出大段源码全文。",
          "maxIterations": "={{ $json.callLimit }}"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2.2,
      "position": [
        2000,
        -60
      ],
      "id": "77ebd930-8d7f-4fb8-93a0-e3a993dd4dbd",
      "name": "Agent graph-lite",
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "jsCode": "// Parse AI Agent output into {line, findings[]} while preserving context fields (e.g., cacheKey/projectKey).\nconst ctx = $json || {};\nconst line = ctx.line || (ctx.context && ctx.context.line) || \"unknown\";\n\nfunction extractText(v) {\n  if (v === null || v === undefined) return \"\";\n  if (typeof v === \"string\") return v;\n  try { return JSON.stringify(v); } catch (e) { return String(v); }\n}\n\nlet raw = ctx.output ?? ctx.text ?? ctx.data ?? ctx;\nlet s = extractText(raw).trim();\n\n// Strip markdown fences if present\nconst fence = s.match(/```json\\s*([\\s\\S]*?)```/i);\nif (fence && fence[1]) s = fence[1].trim();\n\nlet findings = [];\nlet parseOk = false;\nlet parseError = \"\";\n\nif (!s) {\n  parseError = \"empty_response\";\n} else {\n  try {\n    const obj = JSON.parse(s);\n    if (Array.isArray(obj)) {\n      findings = obj;\n      parseOk = true;\n    } else if (obj && typeof obj === \"object\") {\n      if (Array.isArray(obj.findings)) {\n        findings = obj.findings;\n        parseOk = true;\n      } else if (Array.isArray(obj.data)) {\n        findings = obj.data;\n        parseOk = true;\n      } else {\n        parseError = \"json_object_without_findings_array\";\n      }\n    } else {\n      parseError = \"json_not_array\";\n    }\n  } catch (e) {\n    parseError = e.message || String(e);\n  }\n}\n\nif (!parseOk) {\n  throw new Error(`[${line}] parse failed: ${parseError}`);\n}\n\nreturn [{\n  json: {\n    ...ctx,\n    line,\n    parseOk,\n    parseError,\n    findings: Array.isArray(findings) ? findings : []\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2200,
        -60
      ],
      "id": "c9027fb0-8ec9-4beb-b42e-36ba6239006e",
      "name": "Parse graph-lite"
    },
    {
      "parameters": {
        "jsCode": "// Prepare cacheValue JSON for graph-lite\nconst j = $json || {};\nif (j.parseOk !== true) {\n  return [];\n}\nconst cacheValue = JSON.stringify({\n  line: \"graph-lite\",\n  savedAt: new Date().toISOString(),\n  findings: Array.isArray(j.findings) ? j.findings : []\n});\nreturn [{\n  json: {\n    ...j,\n    cacheValue\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2400,
        -60
      ],
      "id": "df1ecd67-c356-43aa-9734-87f2bc2a450b",
      "name": "Prepare Cache Value graph-lite"
    },
    {
      "parameters": {
        "operation": "set",
        "key": "={{ $json.cacheKey }}",
        "value": "={{ $json.cacheValue }}",
        "keyType": "string",
        "expire": true,
        "ttl": "={{ $json.cacheTtlSeconds }}"
      },
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [
        2600,
        -60
      ],
      "id": "bcfe8f59-c81b-4afb-898b-5d5910d98157",
      "name": "Redis SET graph-lite",
      "continueOnFail": true,
      "retryOnFail": true,
      "maxTries": 2,
      "waitBetweenTries": 500,
      "credentials": {
        "redis": {
          "id": "REPLACE_WITH_YOUR_REDIS_CREDENTIAL_ID",
          "name": "Redis account"
        }
      },
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "jsCode": "// Build Redis cacheKey for line: vul-rules\nconst strategyVersion = $json.strategyVersion || '5lines-v1';\nconst projectKey = $json.projectKey || 'unknown';\nconst cacheKey = `ja:5lines:${strategyVersion}:${projectKey}:vul-rules`;\n\nreturn [{\n  json: {\n    ...$json,\n    line: \"vul-rules\",\n    cacheKey\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1000,
        60
      ],
      "id": "3b40da87-e30c-46aa-a31a-c7d5a6307a93",
      "name": "Build Cache Key vul-rules"
    },
    {
      "parameters": {
        "operation": "get",
        "key": "={{ $json.cacheKey }}",
        "options": {}
      },
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [
        1200,
        60
      ],
      "id": "a8c2934a-06b1-4ecc-9ab5-081f2d360b17",
      "name": "Redis GET vul-rules",
      "continueOnFail": true,
      "retryOnFail": true,
      "maxTries": 2,
      "waitBetweenTries": 500,
      "credentials": {
        "redis": {
          "id": "REPLACE_WITH_YOUR_REDIS_CREDENTIAL_ID",
          "name": "Redis account"
        }
      },
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "jsCode": "// Interpret Redis GET output and decide cacheHit.\n// Expected Redis node shape for GET: { value: <string|null> }.\n// We only inspect known value fields to avoid accidentally treating other context strings as cache values.\nconst j = $json || {};\n\nfunction getRedisValue(obj) {\n  if (!obj || typeof obj !== 'object') return null;\n\n  if (typeof obj.value === 'string' || obj.value === null) return obj.value;\n  if (typeof obj.data === 'string' || obj.data === null) return obj.data;\n  if (typeof obj.result === 'string' || obj.result === null) return obj.result;\n\n  // Some variants may nest under \"redis\"\n  if (obj.redis && typeof obj.redis === 'object') {\n    const r = obj.redis;\n    if (typeof r.value === 'string' || r.value === null) return r.value;\n    if (typeof r.data === 'string' || r.data === null) return r.data;\n    if (typeof r.result === 'string' || r.result === null) return r.result;\n  }\n\n  return null;\n}\n\nconst rawVal = getRedisValue(j);\nconst rawStr = (typeof rawVal === 'string') ? rawVal : '';\n\nlet cacheHit = false;\nlet cacheParseOk = false;\nlet cachedRecord = null;\nlet cacheError = null;\n\nif (rawStr && rawStr.trim().length > 0) {\n  try {\n    cachedRecord = JSON.parse(rawStr);\n    cacheParseOk = true;\n    cacheHit = true;\n  } catch (e) {\n    cacheError = `cache_json_parse_error: ${String(e)}`;\n  }\n}\n\nreturn {\n  json: {\n    ...j,\n    cacheHit,\n    cacheParseOk,\n    cacheError,\n    cachedRecord,\n    cacheValuePreview: rawStr.length > 500 ? rawStr.slice(0, 500) + '...(truncated)' : rawStr\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1400,
        60
      ],
      "id": "7628c487-1bda-4a5d-84ff-3416b768d846",
      "name": "Interpret Cache vul-rules"
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.cacheHit }}",
              "operation": "isTrue"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        1600,
        60
      ],
      "id": "4afeb0a7-1a5b-4208-ae10-970e48a433a2",
      "name": "If Cache Hit vul-rules"
    },
    {
      "parameters": {
        "jsCode": "// Use cachedRecord for vul-rules\nconst j = $json || {};\nconst rec = j.cachedRecord;\nlet findings = [];\nif (rec) {\n  if (Array.isArray(rec.findings)) findings = rec.findings;\n  else if (Array.isArray(rec)) findings = rec;\n  else if (typeof rec === 'object') findings = [rec];\n}\nreturn [{\n  json: {\n    ...j,\n    line: \"vul-rules\",\n    cacheHit: true,\n    parseOk: j.cacheParseOk === true,\n    parseError: j.cacheError || \"\",\n    findings\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1800,
        0
      ],
      "id": "8c96911a-c479-47ff-80d7-2dcfcd08c300",
      "name": "Use Cached vul-rules"
    },
    {
      "parameters": {
        "jsCode": "const cfg = $json.scanConfig || {};\nconst lim = cfg.limits && cfg.limits.vulRules ? cfg.limits.vulRules : {};\nconst callLimit = lim.callLimit || 10;\n\nconst levels = Array.isArray(lim.levels) && lim.levels.length ? lim.levels : [\"high\"];\nconst perRuleLimit = lim.perRuleLimit || 15;\nconst totalLimit = lim.totalLimit || 160;\nconst groupBy = lim.groupBy || \"rule\";\n\nconst chatInput = `\n你正在执行 **vul-rules**（规则线）。\n目标：使用 vulnerability.yaml 规则在全局搜索调用点，并将命中转换为 JSON findings。\n\n执行步骤（按 levels 顺序，务必控量）：\n1) 可选：get_vul_rules 获取规则概览（用于了解可用 rule 名称）\n2) 对每个 level ∈ ${JSON.stringify(levels)}：\n   - 调用 vul_search(level=level, groupBy=\"rule\", totalLimit=${totalLimit}, limit=${perRuleLimit})\n   - 对命中 count>0 的规则（优先 high 命中多的）：\n     再调用 vul_search(name=ruleName, level=level, groupBy=\"method\", totalLimit=${totalLimit}, limit=${perRuleLimit})\n3) 将每个 MethodResult 命中点输出为 finding：\n   - line=\"vul-rules\"\n   - type：可直接用 \"vul-rule::<ruleName>\"（也可以映射为更具体类型）\n   - severity：来自 rule 的 level（high/medium/low）\n   - confidence：medium（规则命中是调用点，仍需结合入口/参数判定可利用性）\n   - trace：至少包含命中方法（class/method/desc）；若结果中带 actualPath/restfulType/jarName，可放入 evidence\n注意：\n- 不要输出重复项（同一 class#method#desc + 同一 ruleName 只输出一次）\n- 无发现输出 []\n`;\nreturn [{ json: { ...$json, line: \"vul-rules\", callLimit, chatInput } }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1800,
        120
      ],
      "id": "ebbc6790-f85c-40b9-bc2c-8789aad8ad09",
      "name": "Build Prompt vul-rules"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.chatInput }}",
        "options": {
          "systemMessage": "你是资深 Java 安全审计工程师，目标是做自动化安全审计（静态分析）。\n必须遵守：\n1) 只能使用当前可用的 MCP 工具获取事实证据；禁止凭空猜测。\n2) 严格控制输出规模：优先使用批量/limit/compact/totalLimit 参数。\n3) 只输出 JSON 数组（不要输出解释、不要 Markdown、不要代码块围栏）。没有发现则输出 []。\n4) findings 数组元素必须包含字段：\n   - line (string)\n   - type (string)\n   - severity (\"high\"|\"medium\"|\"low\")\n   - confidence (\"high\"|\"medium\"|\"low\")\n   - score (1-10 整数)\n   - reason (string, 简洁说明命中原因与证据点)\n   - trace (array, 每项包含 {\"class\",\"method\",\"desc\"}；desc 可为空字符串)\n可以附加 evidence/metadata 等字段，但不要输出大段源码全文。",
          "maxIterations": "={{ $json.callLimit }}"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2.2,
      "position": [
        2000,
        120
      ],
      "id": "e83b2cd9-bb7e-4986-8ca8-8bdf609d6b6c",
      "name": "Agent vul-rules",
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "jsCode": "// Parse AI Agent output into {line, findings[]} while preserving context fields (e.g., cacheKey/projectKey).\nconst ctx = $json || {};\nconst line = ctx.line || (ctx.context && ctx.context.line) || \"unknown\";\n\nfunction extractText(v) {\n  if (v === null || v === undefined) return \"\";\n  if (typeof v === \"string\") return v;\n  try { return JSON.stringify(v); } catch (e) { return String(v); }\n}\n\nlet raw = ctx.output ?? ctx.text ?? ctx.data ?? ctx;\nlet s = extractText(raw).trim();\n\n// Strip markdown fences if present\nconst fence = s.match(/```json\\s*([\\s\\S]*?)```/i);\nif (fence && fence[1]) s = fence[1].trim();\n\nlet findings = [];\nlet parseOk = false;\nlet parseError = \"\";\n\nif (!s) {\n  parseError = \"empty_response\";\n} else {\n  try {\n    const obj = JSON.parse(s);\n    if (Array.isArray(obj)) {\n      findings = obj;\n      parseOk = true;\n    } else if (obj && typeof obj === \"object\") {\n      if (Array.isArray(obj.findings)) {\n        findings = obj.findings;\n        parseOk = true;\n      } else if (Array.isArray(obj.data)) {\n        findings = obj.data;\n        parseOk = true;\n      } else {\n        parseError = \"json_object_without_findings_array\";\n      }\n    } else {\n      parseError = \"json_not_array\";\n    }\n  } catch (e) {\n    parseError = e.message || String(e);\n  }\n}\n\nif (!parseOk) {\n  throw new Error(`[${line}] parse failed: ${parseError}`);\n}\n\nreturn [{\n  json: {\n    ...ctx,\n    line,\n    parseOk,\n    parseError,\n    findings: Array.isArray(findings) ? findings : []\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2200,
        120
      ],
      "id": "0a0549c8-2840-4816-988b-3a7915717eed",
      "name": "Parse vul-rules"
    },
    {
      "parameters": {
        "jsCode": "// Prepare cacheValue JSON for vul-rules\nconst j = $json || {};\nif (j.parseOk !== true) {\n  return [];\n}\nconst cacheValue = JSON.stringify({\n  line: \"vul-rules\",\n  savedAt: new Date().toISOString(),\n  findings: Array.isArray(j.findings) ? j.findings : []\n});\nreturn [{\n  json: {\n    ...j,\n    cacheValue\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2400,
        120
      ],
      "id": "4b10cace-8914-4bd9-b8c0-5a7c8a342954",
      "name": "Prepare Cache Value vul-rules"
    },
    {
      "parameters": {
        "operation": "set",
        "key": "={{ $json.cacheKey }}",
        "value": "={{ $json.cacheValue }}",
        "keyType": "string",
        "expire": true,
        "ttl": "={{ $json.cacheTtlSeconds }}"
      },
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [
        2600,
        120
      ],
      "id": "c4be20da-4824-4af1-b002-d8c49d7491eb",
      "name": "Redis SET vul-rules",
      "continueOnFail": true,
      "retryOnFail": true,
      "maxTries": 2,
      "waitBetweenTries": 500,
      "credentials": {
        "redis": {
          "id": "REPLACE_WITH_YOUR_REDIS_CREDENTIAL_ID",
          "name": "Redis account"
        }
      },
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "jsCode": "// Build Redis cacheKey for line: sca-leak\nconst strategyVersion = $json.strategyVersion || '5lines-v1';\nconst projectKey = $json.projectKey || 'unknown';\nconst cacheKey = `ja:5lines:${strategyVersion}:${projectKey}:sca-leak`;\n\nreturn [{\n  json: {\n    ...$json,\n    line: \"sca-leak\",\n    cacheKey\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1000,
        240
      ],
      "id": "8d0d62a4-337e-46c1-9b6c-424a77d2b84d",
      "name": "Build Cache Key sca-leak"
    },
    {
      "parameters": {
        "operation": "get",
        "key": "={{ $json.cacheKey }}",
        "options": {}
      },
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [
        1200,
        240
      ],
      "id": "6f2565b2-4ee0-465c-9df4-efcf4035130b",
      "name": "Redis GET sca-leak",
      "continueOnFail": true,
      "retryOnFail": true,
      "maxTries": 2,
      "waitBetweenTries": 500,
      "credentials": {
        "redis": {
          "id": "REPLACE_WITH_YOUR_REDIS_CREDENTIAL_ID",
          "name": "Redis account"
        }
      },
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "jsCode": "// Interpret Redis GET output and decide cacheHit.\n// Expected Redis node shape for GET: { value: <string|null> }.\n// We only inspect known value fields to avoid accidentally treating other context strings as cache values.\nconst j = $json || {};\n\nfunction getRedisValue(obj) {\n  if (!obj || typeof obj !== 'object') return null;\n\n  if (typeof obj.value === 'string' || obj.value === null) return obj.value;\n  if (typeof obj.data === 'string' || obj.data === null) return obj.data;\n  if (typeof obj.result === 'string' || obj.result === null) return obj.result;\n\n  // Some variants may nest under \"redis\"\n  if (obj.redis && typeof obj.redis === 'object') {\n    const r = obj.redis;\n    if (typeof r.value === 'string' || r.value === null) return r.value;\n    if (typeof r.data === 'string' || r.data === null) return r.data;\n    if (typeof r.result === 'string' || r.result === null) return r.result;\n  }\n\n  return null;\n}\n\nconst rawVal = getRedisValue(j);\nconst rawStr = (typeof rawVal === 'string') ? rawVal : '';\n\nlet cacheHit = false;\nlet cacheParseOk = false;\nlet cachedRecord = null;\nlet cacheError = null;\n\nif (rawStr && rawStr.trim().length > 0) {\n  try {\n    cachedRecord = JSON.parse(rawStr);\n    cacheParseOk = true;\n    cacheHit = true;\n  } catch (e) {\n    cacheError = `cache_json_parse_error: ${String(e)}`;\n  }\n}\n\nreturn {\n  json: {\n    ...j,\n    cacheHit,\n    cacheParseOk,\n    cacheError,\n    cachedRecord,\n    cacheValuePreview: rawStr.length > 500 ? rawStr.slice(0, 500) + '...(truncated)' : rawStr\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1400,
        240
      ],
      "id": "78ca9e05-9434-454d-bcb5-455e70bff32c",
      "name": "Interpret Cache sca-leak"
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.cacheHit }}",
              "operation": "isTrue"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        1600,
        240
      ],
      "id": "bc7df292-3f6c-47d4-8ca7-94169104a883",
      "name": "If Cache Hit sca-leak"
    },
    {
      "parameters": {
        "jsCode": "// Use cachedRecord for sca-leak\nconst j = $json || {};\nconst rec = j.cachedRecord;\nlet findings = [];\nif (rec) {\n  if (Array.isArray(rec.findings)) findings = rec.findings;\n  else if (Array.isArray(rec)) findings = rec;\n  else if (typeof rec === 'object') findings = [rec];\n}\nreturn [{\n  json: {\n    ...j,\n    line: \"sca-leak\",\n    cacheHit: true,\n    parseOk: j.cacheParseOk === true,\n    parseError: j.cacheError || \"\",\n    findings\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1800,
        180
      ],
      "id": "dbf29ced-4e76-4a04-9acd-f2719317a1d3",
      "name": "Use Cached sca-leak"
    },
    {
      "parameters": {
        "jsCode": "const cfg = $json.scanConfig || {};\nconst lim = cfg.limits && cfg.limits.scaLeak ? cfg.limits.scaLeak : {};\nconst callLimit = lim.callLimit || 10;\n\nconst enableSca = lim.enableSca !== false;\nconst enableLeak = lim.enableLeak !== false;\nconst enableGadget = lim.enableGadget === true;\nconst gadgetDir = lim.gadgetDir || '';\nconst leakLimit = lim.leakLimit || 120;\n\nconst chatInput = `\n你正在执行 **sca-leak**（依赖/泄露线）。\n目标：执行 SCA 漏洞依赖扫描 + 泄露扫描（可选 gadget 扫描），输出 JSON findings。\n\n执行步骤：\n1) ${enableSca ? \"调用 sca_scan(log4j=1, fastjson=1, shiro=1) 获取依赖漏洞命中（CVE/cvss/jarPath/project/version）。\" : \"跳过 sca_scan（enableSca=false）。\"}\n2) ${enableLeak ? `调用 leak_scan(limit=${leakLimit}, scope=\"${cfg.scope||'app'}\") 获取泄露（typeName/value/className/jarName）。` : \"跳过 leak_scan（enableLeak=false）。\"}\n3) ${enableGadget ? `调用 gadget_scan(dir=\"${gadgetDir}\", native=1, hessian=1, fastjson=1, jdbc=1) 获取 gadget 依赖链命中。` : \"gadget_scan 默认关闭（enableGadget=false 或 gadgetDir 为空）。\"}\n\n输出规范：\n- SCA 命中：type=\"dependency_cve\"，severity 按 cvss（>=9 high, >=7 medium, else low），confidence=high\n- 泄露命中：type=\"secret_leak\"，severity=high，confidence=high（reason 需包含 typeName 与脱敏 value 片段）\n- gadget 命中：type=\"gadget_presence\" 或 \"deserialization_gadget\"，severity=medium/high，confidence=medium/high\n- trace：至少包含 1 个点；对于 SCA 可用 jarPath 作为 trace 的 desc（class/method 可留空但必须给字段）；对于 leak 可用 className 作为 class\n注意：\n- 输出 value 时务必脱敏：只保留前 4 + 后 4（中间用 ***）\n- 无发现输出 []\n`;\nreturn [{ json: { ...$json, line: \"sca-leak\", callLimit, chatInput } }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1800,
        300
      ],
      "id": "6001ad06-f7f1-43c6-a825-16f7291b3fc4",
      "name": "Build Prompt sca-leak"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.chatInput }}",
        "options": {
          "systemMessage": "你是资深 Java 安全审计工程师，目标是做自动化安全审计（静态分析）。\n必须遵守：\n1) 只能使用当前可用的 MCP 工具获取事实证据；禁止凭空猜测。\n2) 严格控制输出规模：优先使用批量/limit/compact/totalLimit 参数。\n3) 只输出 JSON 数组（不要输出解释、不要 Markdown、不要代码块围栏）。没有发现则输出 []。\n4) findings 数组元素必须包含字段：\n   - line (string)\n   - type (string)\n   - severity (\"high\"|\"medium\"|\"low\")\n   - confidence (\"high\"|\"medium\"|\"low\")\n   - score (1-10 整数)\n   - reason (string, 简洁说明命中原因与证据点)\n   - trace (array, 每项包含 {\"class\",\"method\",\"desc\"}；desc 可为空字符串)\n可以附加 evidence/metadata 等字段，但不要输出大段源码全文。",
          "maxIterations": "={{ $json.callLimit }}"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2.2,
      "position": [
        2000,
        300
      ],
      "id": "d7310326-e6a3-43a9-9761-03df097af76c",
      "name": "Agent sca-leak",
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "jsCode": "// Parse AI Agent output into {line, findings[]} while preserving context fields (e.g., cacheKey/projectKey).\nconst ctx = $json || {};\nconst line = ctx.line || (ctx.context && ctx.context.line) || \"unknown\";\n\nfunction extractText(v) {\n  if (v === null || v === undefined) return \"\";\n  if (typeof v === \"string\") return v;\n  try { return JSON.stringify(v); } catch (e) { return String(v); }\n}\n\nlet raw = ctx.output ?? ctx.text ?? ctx.data ?? ctx;\nlet s = extractText(raw).trim();\n\n// Strip markdown fences if present\nconst fence = s.match(/```json\\s*([\\s\\S]*?)```/i);\nif (fence && fence[1]) s = fence[1].trim();\n\nlet findings = [];\nlet parseOk = false;\nlet parseError = \"\";\n\nif (!s) {\n  parseError = \"empty_response\";\n} else {\n  try {\n    const obj = JSON.parse(s);\n    if (Array.isArray(obj)) {\n      findings = obj;\n      parseOk = true;\n    } else if (obj && typeof obj === \"object\") {\n      if (Array.isArray(obj.findings)) {\n        findings = obj.findings;\n        parseOk = true;\n      } else if (Array.isArray(obj.data)) {\n        findings = obj.data;\n        parseOk = true;\n      } else {\n        parseError = \"json_object_without_findings_array\";\n      }\n    } else {\n      parseError = \"json_not_array\";\n    }\n  } catch (e) {\n    parseError = e.message || String(e);\n  }\n}\n\nif (!parseOk) {\n  throw new Error(`[${line}] parse failed: ${parseError}`);\n}\n\nreturn [{\n  json: {\n    ...ctx,\n    line,\n    parseOk,\n    parseError,\n    findings: Array.isArray(findings) ? findings : []\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2200,
        300
      ],
      "id": "0461215b-edd7-4741-bc2b-1d0b4e58acd0",
      "name": "Parse sca-leak"
    },
    {
      "parameters": {
        "jsCode": "// Prepare cacheValue JSON for sca-leak\nconst j = $json || {};\nif (j.parseOk !== true) {\n  return [];\n}\nconst cacheValue = JSON.stringify({\n  line: \"sca-leak\",\n  savedAt: new Date().toISOString(),\n  findings: Array.isArray(j.findings) ? j.findings : []\n});\nreturn [{\n  json: {\n    ...j,\n    cacheValue\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2400,
        300
      ],
      "id": "4f1788bd-10e2-4f63-8128-63173efc9b67",
      "name": "Prepare Cache Value sca-leak"
    },
    {
      "parameters": {
        "operation": "set",
        "key": "={{ $json.cacheKey }}",
        "value": "={{ $json.cacheValue }}",
        "keyType": "string",
        "expire": true,
        "ttl": "={{ $json.cacheTtlSeconds }}"
      },
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [
        2600,
        300
      ],
      "id": "3c6bd6d3-e297-4759-8f3b-48651eb34264",
      "name": "Redis SET sca-leak",
      "continueOnFail": true,
      "retryOnFail": true,
      "maxTries": 2,
      "waitBetweenTries": 500,
      "credentials": {
        "redis": {
          "id": "REPLACE_WITH_YOUR_REDIS_CREDENTIAL_ID",
          "name": "Redis account"
        }
      },
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.scanConfig.enableDfsTaint }}",
              "operation": "isTrue"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        1000,
        420
      ],
      "id": "f213b8c5-b800-4219-bf53-75a295fe048e",
      "name": "If Enable dfs-taint"
    },
    {
      "parameters": {
        "jsCode": "// DFS slow line disabled: return empty findings placeholder so merge can proceed.\nreturn [{\n  json: {\n    line: \"dfs-taint\",\n    parseOk: true,\n    parseError: \"disabled\",\n    findings: []\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1200,
        520
      ],
      "id": "572dc3b4-0f6f-43f8-bfeb-d3f29ed8783f",
      "name": "DFS Disabled"
    },
    {
      "parameters": {
        "jsCode": "// Build Redis cacheKey for line: dfs-taint\nconst strategyVersion = $json.strategyVersion || '5lines-v1';\nconst projectKey = $json.projectKey || 'unknown';\nconst cacheKey = `ja:5lines:${strategyVersion}:${projectKey}:dfs-taint`;\n\nreturn [{\n  json: {\n    ...$json,\n    line: \"dfs-taint\",\n    cacheKey\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1200,
        360
      ],
      "id": "0b99da5d-8537-47b8-b793-7d1df5acdc1c",
      "name": "Build Cache Key dfs-taint"
    },
    {
      "parameters": {
        "operation": "get",
        "key": "={{ $json.cacheKey }}",
        "options": {}
      },
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [
        1400,
        360
      ],
      "id": "322faaa2-0b02-4e91-9bee-b4bfd12b64ec",
      "name": "Redis GET dfs-taint",
      "continueOnFail": true,
      "retryOnFail": true,
      "maxTries": 2,
      "waitBetweenTries": 500,
      "credentials": {
        "redis": {
          "id": "REPLACE_WITH_YOUR_REDIS_CREDENTIAL_ID",
          "name": "Redis account"
        }
      },
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "jsCode": "// Interpret Redis GET output and decide cacheHit.\n// Expected Redis node shape for GET: { value: <string|null> }.\n// We only inspect known value fields to avoid accidentally treating other context strings as cache values.\nconst j = $json || {};\n\nfunction getRedisValue(obj) {\n  if (!obj || typeof obj !== 'object') return null;\n\n  if (typeof obj.value === 'string' || obj.value === null) return obj.value;\n  if (typeof obj.data === 'string' || obj.data === null) return obj.data;\n  if (typeof obj.result === 'string' || obj.result === null) return obj.result;\n\n  // Some variants may nest under \"redis\"\n  if (obj.redis && typeof obj.redis === 'object') {\n    const r = obj.redis;\n    if (typeof r.value === 'string' || r.value === null) return r.value;\n    if (typeof r.data === 'string' || r.data === null) return r.data;\n    if (typeof r.result === 'string' || r.result === null) return r.result;\n  }\n\n  return null;\n}\n\nconst rawVal = getRedisValue(j);\nconst rawStr = (typeof rawVal === 'string') ? rawVal : '';\n\nlet cacheHit = false;\nlet cacheParseOk = false;\nlet cachedRecord = null;\nlet cacheError = null;\n\nif (rawStr && rawStr.trim().length > 0) {\n  try {\n    cachedRecord = JSON.parse(rawStr);\n    cacheParseOk = true;\n    cacheHit = true;\n  } catch (e) {\n    cacheError = `cache_json_parse_error: ${String(e)}`;\n  }\n}\n\nreturn {\n  json: {\n    ...j,\n    cacheHit,\n    cacheParseOk,\n    cacheError,\n    cachedRecord,\n    cacheValuePreview: rawStr.length > 500 ? rawStr.slice(0, 500) + '...(truncated)' : rawStr\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1600,
        360
      ],
      "id": "6cca2c17-d8f9-4573-b502-6641aaf357a5",
      "name": "Interpret Cache dfs-taint"
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.cacheHit }}",
              "operation": "isTrue"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        1800,
        360
      ],
      "id": "0723c099-af72-45e7-983b-dba4a1a8effc",
      "name": "If Cache Hit dfs-taint"
    },
    {
      "parameters": {
        "jsCode": "// Use cachedRecord for dfs-taint\nconst j = $json || {};\nconst rec = j.cachedRecord;\nlet findings = [];\nif (rec) {\n  if (Array.isArray(rec.findings)) findings = rec.findings;\n  else if (Array.isArray(rec)) findings = rec;\n  else if (typeof rec === 'object') findings = [rec];\n}\nreturn [{\n  json: {\n    ...j,\n    line: \"dfs-taint\",\n    cacheHit: true,\n    parseOk: j.cacheParseOk === true,\n    parseError: j.cacheError || \"\",\n    findings\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2000,
        300
      ],
      "id": "09ec94d4-d778-4945-90bb-c9c50f587bbc",
      "name": "Use Cached dfs-taint"
    },
    {
      "parameters": {
        "jsCode": "const cfg = $json.scanConfig || {};\nconst lim = cfg.limits && cfg.limits.dfsTaint ? cfg.limits.dfsTaint : {};\nconst callLimit = lim.callLimit || 28;\n\nconst sinkNames = Array.isArray(lim.sinkNames) && lim.sinkNames.length ? lim.sinkNames : [\"Runtime.exec(String)\"];\nconst depth = lim.depth || 10;\nconst maxLimit = lim.maxLimit || 80;\nconst maxPaths = lim.maxPaths || 80;\nconst timeoutMs = lim.timeoutMs || 90000;\nconst onlyFromWeb = lim.onlyFromWeb !== false;\nconst resultLimit = lim.resultLimit || 120;\nconst compact = lim.compact !== false;\n\nconst chatInput = `\n你正在执行 **dfs-taint**（慢线：DFS/污点链路）。这是可选慢线，可能耗时。\n目标：对关键 sink 触发 DFS 搜索所有可达 source（尽量 onlyFromWeb），拿到链路并输出 findings。\n\n执行步骤（务必控量）：\n1) 对 sinkName ∈ ${JSON.stringify(sinkNames)} 逐个调用：\n   - get_dfs_chains(mode=\"sink\", sinkName=sinkName, searchAllSources=true, depth=${depth}, maxLimit=${maxLimit}, maxPaths=${maxPaths}, timeoutMs=${timeoutMs}, onlyFromWeb=${onlyFromWeb})\n   记录返回的 jobId\n2) 对每个 jobId：\n   - 轮询 get_dfs_job(jobId) 直到 status 为 finished/done 或 error（必要时少量重试）\n   - 完成后调用 get_dfs_results(jobId, limit=${resultLimit}, offset=0, compact=${compact})\n3) 将每条 DFSResult 转换为 finding：\n   - type：基于 sinkName 分类（command_exec/sql/jndi/deserialization/ssrf/file_io 等）\n   - severity：通常 high（链路可达）\n   - confidence：high/medium（onlyFromWeb=true 则更高）\n   - trace：使用 results.items[].methods（compact=true 时字段可能是 methods），从 source 到 sink 的方法序列\n注意：\n- 如果 job 结果为空或被 truncated，也可输出 1 条低置信度 findings，reason 说明 truncated/recommend\n- 无发现输出 []\n`;\nreturn [{ json: { ...$json, line: \"dfs-taint\", callLimit, chatInput } }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2000,
        420
      ],
      "id": "374f7b98-30d3-4b5b-aabc-e6e5e8c8a5d5",
      "name": "Build Prompt dfs-taint"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.chatInput }}",
        "options": {
          "systemMessage": "你是资深 Java 安全审计工程师，目标是做自动化安全审计（静态分析）。\n必须遵守：\n1) 只能使用当前可用的 MCP 工具获取事实证据；禁止凭空猜测。\n2) 严格控制输出规模：优先使用批量/limit/compact/totalLimit 参数。\n3) 只输出 JSON 数组（不要输出解释、不要 Markdown、不要代码块围栏）。没有发现则输出 []。\n4) findings 数组元素必须包含字段：\n   - line (string)\n   - type (string)\n   - severity (\"high\"|\"medium\"|\"low\")\n   - confidence (\"high\"|\"medium\"|\"low\")\n   - score (1-10 整数)\n   - reason (string, 简洁说明命中原因与证据点)\n   - trace (array, 每项包含 {\"class\",\"method\",\"desc\"}；desc 可为空字符串)\n可以附加 evidence/metadata 等字段，但不要输出大段源码全文。",
          "maxIterations": "={{ $json.callLimit }}"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2.2,
      "position": [
        2200,
        420
      ],
      "id": "41e37e67-e75c-450b-a4bf-02965fc4c2a4",
      "name": "Agent dfs-taint",
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "jsCode": "// Parse AI Agent output into {line, findings[]} while preserving context fields (e.g., cacheKey/projectKey).\nconst ctx = $json || {};\nconst line = ctx.line || (ctx.context && ctx.context.line) || \"unknown\";\n\nfunction extractText(v) {\n  if (v === null || v === undefined) return \"\";\n  if (typeof v === \"string\") return v;\n  try { return JSON.stringify(v); } catch (e) { return String(v); }\n}\n\nlet raw = ctx.output ?? ctx.text ?? ctx.data ?? ctx;\nlet s = extractText(raw).trim();\n\n// Strip markdown fences if present\nconst fence = s.match(/```json\\s*([\\s\\S]*?)```/i);\nif (fence && fence[1]) s = fence[1].trim();\n\nlet findings = [];\nlet parseOk = false;\nlet parseError = \"\";\n\nif (!s) {\n  parseError = \"empty_response\";\n} else {\n  try {\n    const obj = JSON.parse(s);\n    if (Array.isArray(obj)) {\n      findings = obj;\n      parseOk = true;\n    } else if (obj && typeof obj === \"object\") {\n      if (Array.isArray(obj.findings)) {\n        findings = obj.findings;\n        parseOk = true;\n      } else if (Array.isArray(obj.data)) {\n        findings = obj.data;\n        parseOk = true;\n      } else {\n        parseError = \"json_object_without_findings_array\";\n      }\n    } else {\n      parseError = \"json_not_array\";\n    }\n  } catch (e) {\n    parseError = e.message || String(e);\n  }\n}\n\nif (!parseOk) {\n  throw new Error(`[${line}] parse failed: ${parseError}`);\n}\n\nreturn [{\n  json: {\n    ...ctx,\n    line,\n    parseOk,\n    parseError,\n    findings: Array.isArray(findings) ? findings : []\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2400,
        420
      ],
      "id": "37b89d74-a825-46e4-8a4f-08688e32cddf",
      "name": "Parse dfs-taint"
    },
    {
      "parameters": {
        "jsCode": "// Prepare cacheValue JSON for dfs-taint\nconst j = $json || {};\nif (j.parseOk !== true) {\n  return [];\n}\nconst cacheValue = JSON.stringify({\n  line: \"dfs-taint\",\n  savedAt: new Date().toISOString(),\n  findings: Array.isArray(j.findings) ? j.findings : []\n});\nreturn [{\n  json: {\n    ...j,\n    cacheValue\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2600,
        420
      ],
      "id": "51dc9025-e9c3-47aa-99e6-97fdfbe0b83d",
      "name": "Prepare Cache Value dfs-taint"
    },
    {
      "parameters": {
        "operation": "set",
        "key": "={{ $json.cacheKey }}",
        "value": "={{ $json.cacheValue }}",
        "keyType": "string",
        "expire": true,
        "ttl": "={{ $json.cacheTtlSeconds }}"
      },
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [
        2800,
        420
      ],
      "id": "a7a26d79-048b-4bdd-a79c-ecb1b76ae8d1",
      "name": "Redis SET dfs-taint",
      "continueOnFail": true,
      "retryOnFail": true,
      "maxTries": 2,
      "waitBetweenTries": 500,
      "credentials": {
        "redis": {
          "id": "REPLACE_WITH_YOUR_REDIS_CREDENTIAL_ID",
          "name": "Redis account"
        }
      },
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "numberInputs": 5
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        3000,
        120
      ],
      "id": "9e0ab6bb-27a6-4c6c-8332-723051b9afdf",
      "name": "Merge Lines"
    },
    {
      "parameters": {
        "jsCode": "// Collect findings from 5 lines (Redis version), normalize schema, de-duplicate,\n// and output one item per unique finding that is NOT already covered by cacheHit results.\nconst inputs = $input.all();\n\nconst allowedSev = new Set(['high','medium','low']);\nconst allowedConf = new Set(['high','medium','low']);\n\nfunction normStr(v) {\n  if (v === null || v === undefined) return '';\n  return String(v);\n}\n\nfunction normLevel(v, defVal) {\n  const s = normStr(v).trim().toLowerCase();\n  if (allowedSev.has(s)) return s;\n  if (allowedConf.has(s)) return s;\n  return defVal;\n}\n\nfunction normalizeClassName(c) {\n  const s = normStr(c).trim();\n  if (!s) return '';\n  return s.replace(/\\//g, '.');\n}\n\nfunction normalizeTrace(trace, fallback) {\n  let t = [];\n  if (Array.isArray(trace)) {\n    t = trace.map(x => {\n      const o = (x && typeof x === 'object') ? x : {};\n      return {\n        class: normalizeClassName(o.class || o.className || o.cls || ''),\n        method: normStr(o.method || o.methodName || '').trim(),\n        desc: normStr(o.desc || o.methodDesc || '').trim(),\n      };\n    }).filter(x => x.class || x.method || x.desc);\n  }\n  if (!t.length && fallback) {\n    t = [fallback].filter(x => x.class || x.method || x.desc);\n  }\n  if (!t.length) t = [{class:'', method:'', desc:''}];\n  return t;\n}\n\nfunction clampInt(n, min, max) {\n  const x = parseInt(n, 10);\n  if (Number.isNaN(x)) return null;\n  return Math.min(max, Math.max(min, x));\n}\n\nfunction scoreBy(sev, conf) {\n  const s = sev || 'low';\n  const c = conf || 'low';\n  const table = {\n    'high':   {'high':9, 'medium':8, 'low':7},\n    'medium': {'high':7, 'medium':6, 'low':5},\n    'low':    {'high':4, 'medium':3, 'low':2},\n  };\n  return table[s]?.[c] ?? 3;\n}\n\nfunction maskSecret(v) {\n  const s = normStr(v).trim();\n  if (s.length <= 8) return s ? (s[0] + '***') : '';\n  return s.slice(0,4) + '***' + s.slice(-4);\n}\n\nfunction canonicalType(line, type, f) {\n  const t = normStr(type).trim();\n  const ruleName = normStr(f.ruleName || f.rule || f.name || '').trim();\n  const sinkName = normStr(f.sinkName || f.sink || '').trim();\n\n  if (t.startsWith('vul-rule::')) return t;\n\n  if (line === 'vul-rules') {\n    if (ruleName) return `vul-rule::${ruleName}`;\n    if (t) return `vul-rule::${t}`;\n  }\n\n  const sname = sinkName || t;\n  if (/Runtime\\.exec/i.test(sname) || /ProcessBuilder/i.test(sname)) return 'command_execution';\n  if (/InitialContext\\.lookup/i.test(sname) || /Context\\.lookup/i.test(sname) || /DirContext\\.search/i.test(sname) || /LdapContext\\.search/i.test(sname)) return 'jndi_injection';\n  if (/Statement\\.execute|executeQuery|executeUpdate|prepareStatement/i.test(sname)) return 'sql_injection';\n  if (/ObjectInputStream\\.readObject|XMLDecoder\\.readObject|Hessian.*readObject|XStream\\.fromXML|Yaml\\.load|JSON\\.parseObject|ObjectMapper\\.readValue/i.test(sname)) return 'insecure_deserialization';\n  if (/URL\\.openConnection|HttpURLConnection\\.connect/i.test(sname)) return 'ssrf';\n  if (/File(Input|Output)Stream\\.new|RandomAccessFile\\.new|File\\.delete/i.test(sname)) return 'file_io';\n\n  if (line === 'sca-leak') {\n    if (t === 'secret_leak') return 'secret_leak';\n    if (t === 'dependency_cve') return 'dependency_cve';\n    if (t === 'gadget_presence' || t === 'deserialization_gadget') return t;\n  }\n\n  if (t) return t;\n  return 'unknown';\n}\n\nfunction normalizeFinding(line, f, fromCache) {\n  const obj = (f && typeof f === 'object') ? f : {};\n  const out = {};\n\n  out.line = normStr(obj.line || line || 'unknown').trim() || 'unknown';\n  out.fromCache = !!fromCache;\n\n  out.ruleName = normStr(obj.ruleName || obj.rule || obj.name || '').trim() || undefined;\n  out.sinkName = normStr(obj.sinkName || obj.sink || '').trim() || undefined;\n  out.type = canonicalType(out.line, obj.type, { ...obj, ruleName: out.ruleName, sinkName: out.sinkName });\n\n  let sev = normLevel(obj.severity, 'low');\n  let conf = normLevel(obj.confidence, 'low');\n\n  if (out.type === 'secret_leak') { sev = 'high'; conf = 'high'; }\n\n  const cvss = obj.cvss ?? (obj.evidence && obj.evidence.cvss);\n  const cvssNum = typeof cvss === 'number' ? cvss : parseFloat(cvss);\n  if (out.type === 'dependency_cve' && !Number.isNaN(cvssNum)) {\n    if (cvssNum >= 9.0) sev = 'high';\n    else if (cvssNum >= 7.0) sev = 'medium';\n    else sev = 'low';\n    conf = 'high';\n  }\n\n  out.severity = allowedSev.has(sev) ? sev : 'low';\n  out.confidence = allowedConf.has(conf) ? conf : 'low';\n\n  let score = clampInt(obj.score, 1, 10);\n  if (score === null) {\n    if (out.type === 'dependency_cve' && !Number.isNaN(cvssNum)) {\n      score = Math.max(1, Math.min(10, Math.round(cvssNum)));\n    } else {\n      score = scoreBy(out.severity, out.confidence);\n    }\n  }\n  out.score = score;\n\n  const fallback = {\n    class: normalizeClassName(obj.className || obj.class || ''),\n    method: normStr(obj.methodName || obj.method || '').trim(),\n    desc: normStr(obj.methodDesc || obj.desc || '').trim(),\n  };\n  out.trace = normalizeTrace(obj.trace, fallback);\n\n  let reason = normStr(obj.reason || '').trim();\n  if (!reason) {\n    if (out.type === 'secret_leak') {\n      const tn = normStr(obj.typeName || (obj.evidence && obj.evidence.typeName) || '').trim();\n      const val = maskSecret(obj.value || (obj.evidence && obj.evidence.value));\n      reason = `Potential secret leak (${tn}) value=${val}`;\n    } else if (out.type === 'dependency_cve') {\n      const cve = normStr(obj.cve || (obj.evidence && obj.evidence.cve) || '').trim();\n      const proj = normStr(obj.project || (obj.evidence && obj.evidence.project) || '').trim();\n      const ver = normStr(obj.version || (obj.evidence && obj.evidence.version) || '').trim();\n      reason = `Dependency vulnerability ${cve} ${proj} ${ver}`.trim();\n    } else if (out.type.startsWith('vul-rule::')) {\n      reason = `Rule hit: ${out.type}`;\n    } else {\n      reason = `${out.type} hit`;\n    }\n  }\n  if (reason.length > 500) reason = reason.slice(0, 500) + '...';\n  out.reason = reason;\n\n  if (obj.evidence && typeof obj.evidence === 'object') {\n    out.evidence = obj.evidence;\n  } else {\n    const ev = {};\n    for (const k of ['jarName','jarPath','actualPath','restfulType','path','value','typeName','cve','cvss','project','version','matchedJarNames','matchedJarPaths']) {\n      if (obj[k] !== undefined && obj[k] !== null && normStr(obj[k]).trim() !== '') ev[k] = obj[k];\n    }\n    if (Object.keys(ev).length) out.evidence = ev;\n  }\n\n  return out;\n}\n\nfunction dedupKey(f) {\n  const t0 = f.trace && f.trace.length ? f.trace[0] : {class:'', method:'', desc:''};\n  const anchor = `${t0.class}#${t0.method}${t0.desc ? ':'+t0.desc : ''}`;\n  const extra = f.ruleName ? `|rule=${f.ruleName}` : (f.sinkName ? `|sink=${f.sinkName}` : '');\n  if (f.type === 'secret_leak') {\n    const tn = normStr(f.evidence && f.evidence.typeName || '');\n    const val = maskSecret(f.evidence && f.evidence.value || '');\n    return `${f.type}|${tn}|${val}|${anchor}`;\n  }\n  if (f.type === 'dependency_cve') {\n    const cve = normStr(f.evidence && f.evidence.cve || '');\n    const jar = normStr(f.evidence && f.evidence.jarPath || f.evidence && f.evidence.jarName || '');\n    return `${f.type}|${cve}|${jar}|${anchor}`;\n  }\n  return `${f.type}|${anchor}${extra}`;\n}\n\nfunction rank(f) {\n  const cw = {high:3, medium:2, low:1};\n  return (cw[f.confidence] || 1) * 100 + (cw[f.severity] || 1) * 10 + (f.score || 0);\n}\n\n// Collect all findings with cache flags\nconst all = [];\nfor (const it of inputs) {\n  const line = it.json && it.json.line ? it.json.line : 'unknown';\n  const fromCache = it.json && it.json.cacheHit === true;\n  const arr = Array.isArray(it.json && it.json.findings) ? it.json.findings : [];\n  for (const f of arr) all.push({ line, f, fromCache });\n}\n\n// Normalize, track cached keys, and dedup by best rank\nconst cachedKeys = new Set();\nconst best = new Map();\n\nfor (const {line, f, fromCache} of all) {\n  const nf = normalizeFinding(line, f, fromCache);\n  const key = dedupKey(nf);\n  nf.dedupKey = key;\n\n  if (fromCache) cachedKeys.add(key);\n\n  const prev = best.get(key);\n  if (!prev || rank(nf) > rank(prev)) best.set(key, nf);\n}\n\nconst unique = Array.from(best.values())\n  .filter(f => !cachedKeys.has(f.dedupKey)) // do not re-report keys already in cache\n  .sort((a,b) => rank(b) - rank(a));\n\n// Output items\nreturn unique.map(f => ({ json: f }));"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3200,
        120
      ],
      "id": "cc6f2c6e-6338-46a1-a940-632c4930408f",
      "name": "Collect Normalize Dedup"
    },
    {
      "parameters": {
        "batchSize": 1,
        "options": {}
      },
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [
        3400,
        120
      ],
      "id": "943ea35d-bfb3-4170-a6b8-d4cb7b622130",
      "name": "Loop Findings"
    },
    {
      "parameters": {
        "amount": 200,
        "unit": "milliseconds"
      },
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1,
      "position": [
        3600,
        120
      ],
      "id": "02bdcccd-f216-402a-bce4-63ace8b05294",
      "name": "Rate Limit"
    },
    {
      "parameters": {
        "jsCode": "// Build a deterministic instruction for the reporter agent to call MCP report tool exactly once.\nconst f = $json || {};\nconst type = String(f.type || 'unknown');\nconst reason = String(f.reason || '').trim() || `${type} hit`;\nconst score = (typeof f.score === 'number' ? f.score : parseInt(f.score, 10)) || 5;\n\nlet trace = [];\nif (Array.isArray(f.trace)) {\n  trace = f.trace.map(x => ({\n    class: String(x.class ?? '').replace(/\\//g,'.'),\n    method: String(x.method ?? ''),\n    desc: String(x.desc ?? ''),\n  }));\n}\nif (!trace.length) trace = [{class:'', method:'', desc:''}];\n\nconst payload = { type, reason, score, trace };\n\nconst chatInput = `请使用工具 report 上报以下漏洞。必须只调用一次 report 工具并传入完整 JSON；调用后只输出 {\"ok\":true}。\nreport 参数 JSON：\n${JSON.stringify(payload, null, 2)}\n`;\n\nreturn [{ json: { ...f, callLimit: 2, chatInput, reportPayload: payload } }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3800,
        120
      ],
      "id": "f24178d9-0c98-418d-a1f9-bf6dce108fb6",
      "name": "Build Report Prompt"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.chatInput }}",
        "options": {
          "systemMessage": "你是漏洞报告机器人。\n必须遵守：\n1) 你必须调用一次且仅一次名为 report 的工具来上报漏洞；参数必须严格使用输入中提供的 JSON（不要更改字段名、不要自作主张补充虚构数据）。\n2) 如果输入缺字段，使用空字符串/默认值，但仍需调用 report。\n3) 工具调用完成后，只输出一个 JSON：{\"ok\":true}。不要输出其他解释。",
          "maxIterations": "={{ $json.callLimit }}"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2.2,
      "position": [
        4000,
        120
      ],
      "id": "1a7803ca-6d6f-4c94-89a3-fd0a5a913a54",
      "name": "Reporter Agent",
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "jsCode": "// Workflow finished.\nreturn [{json:{ok:true, message:\"Audit workflow finished\"}}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        4200,
        240
      ],
      "id": "3271c337-b1f6-4be8-8625-eff8884d29df",
      "name": "Done"
    }
  ],
  "connections": {
    "Start Workflow": {
      "main": [
        [
          {
            "node": "Global Constants",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Global Constants": {
      "main": [
        [
          {
            "node": "Get Jars List",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Jars List": {
      "main": [
        [
          {
            "node": "Compute Project Key",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Compute Project Key": {
      "main": [
        [
          {
            "node": "Init Scan Config",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Init Scan Config": {
      "main": [
        [
          {
            "node": "Build Cache Key audit-fast",
            "type": "main",
            "index": 0
          },
          {
            "node": "Build Cache Key graph-lite",
            "type": "main",
            "index": 0
          },
          {
            "node": "Build Cache Key vul-rules",
            "type": "main",
            "index": 0
          },
          {
            "node": "Build Cache Key sca-leak",
            "type": "main",
            "index": 0
          },
          {
            "node": "If Enable dfs-taint",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Cache Key audit-fast": {
      "main": [
        [
          {
            "node": "Redis GET audit-fast",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Redis GET audit-fast": {
      "main": [
        [
          {
            "node": "Interpret Cache audit-fast",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Interpret Cache audit-fast": {
      "main": [
        [
          {
            "node": "If Cache Hit audit-fast",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If Cache Hit audit-fast": {
      "main": [
        [
          {
            "node": "Use Cached audit-fast",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Build Prompt audit-fast",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Use Cached audit-fast": {
      "main": [
        [
          {
            "node": "Merge Lines",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Prompt audit-fast": {
      "main": [
        [
          {
            "node": "Agent audit-fast",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Agent audit-fast": {
      "main": [
        [
          {
            "node": "Parse audit-fast",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse audit-fast": {
      "main": [
        [
          {
            "node": "Merge Lines",
            "type": "main",
            "index": 0
          },
          {
            "node": "Prepare Cache Value audit-fast",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Cache Value audit-fast": {
      "main": [
        [
          {
            "node": "Redis SET audit-fast",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Cache Key graph-lite": {
      "main": [
        [
          {
            "node": "Redis GET graph-lite",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Redis GET graph-lite": {
      "main": [
        [
          {
            "node": "Interpret Cache graph-lite",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Interpret Cache graph-lite": {
      "main": [
        [
          {
            "node": "If Cache Hit graph-lite",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If Cache Hit graph-lite": {
      "main": [
        [
          {
            "node": "Use Cached graph-lite",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Build Prompt graph-lite",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Use Cached graph-lite": {
      "main": [
        [
          {
            "node": "Merge Lines",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Build Prompt graph-lite": {
      "main": [
        [
          {
            "node": "Agent graph-lite",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Agent graph-lite": {
      "main": [
        [
          {
            "node": "Parse graph-lite",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse graph-lite": {
      "main": [
        [
          {
            "node": "Merge Lines",
            "type": "main",
            "index": 1
          },
          {
            "node": "Prepare Cache Value graph-lite",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Cache Value graph-lite": {
      "main": [
        [
          {
            "node": "Redis SET graph-lite",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Cache Key vul-rules": {
      "main": [
        [
          {
            "node": "Redis GET vul-rules",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Redis GET vul-rules": {
      "main": [
        [
          {
            "node": "Interpret Cache vul-rules",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Interpret Cache vul-rules": {
      "main": [
        [
          {
            "node": "If Cache Hit vul-rules",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If Cache Hit vul-rules": {
      "main": [
        [
          {
            "node": "Use Cached vul-rules",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Build Prompt vul-rules",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Use Cached vul-rules": {
      "main": [
        [
          {
            "node": "Merge Lines",
            "type": "main",
            "index": 2
          }
        ]
      ]
    },
    "Build Prompt vul-rules": {
      "main": [
        [
          {
            "node": "Agent vul-rules",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Agent vul-rules": {
      "main": [
        [
          {
            "node": "Parse vul-rules",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse vul-rules": {
      "main": [
        [
          {
            "node": "Merge Lines",
            "type": "main",
            "index": 2
          },
          {
            "node": "Prepare Cache Value vul-rules",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Cache Value vul-rules": {
      "main": [
        [
          {
            "node": "Redis SET vul-rules",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Cache Key sca-leak": {
      "main": [
        [
          {
            "node": "Redis GET sca-leak",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Redis GET sca-leak": {
      "main": [
        [
          {
            "node": "Interpret Cache sca-leak",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Interpret Cache sca-leak": {
      "main": [
        [
          {
            "node": "If Cache Hit sca-leak",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If Cache Hit sca-leak": {
      "main": [
        [
          {
            "node": "Use Cached sca-leak",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Build Prompt sca-leak",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Use Cached sca-leak": {
      "main": [
        [
          {
            "node": "Merge Lines",
            "type": "main",
            "index": 3
          }
        ]
      ]
    },
    "Build Prompt sca-leak": {
      "main": [
        [
          {
            "node": "Agent sca-leak",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Agent sca-leak": {
      "main": [
        [
          {
            "node": "Parse sca-leak",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse sca-leak": {
      "main": [
        [
          {
            "node": "Merge Lines",
            "type": "main",
            "index": 3
          },
          {
            "node": "Prepare Cache Value sca-leak",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Cache Value sca-leak": {
      "main": [
        [
          {
            "node": "Redis SET sca-leak",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If Enable dfs-taint": {
      "main": [
        [
          {
            "node": "Build Cache Key dfs-taint",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "DFS Disabled",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "DFS Disabled": {
      "main": [
        [
          {
            "node": "Merge Lines",
            "type": "main",
            "index": 4
          }
        ]
      ]
    },
    "Build Cache Key dfs-taint": {
      "main": [
        [
          {
            "node": "Redis GET dfs-taint",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Redis GET dfs-taint": {
      "main": [
        [
          {
            "node": "Interpret Cache dfs-taint",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Interpret Cache dfs-taint": {
      "main": [
        [
          {
            "node": "If Cache Hit dfs-taint",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If Cache Hit dfs-taint": {
      "main": [
        [
          {
            "node": "Use Cached dfs-taint",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Build Prompt dfs-taint",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Use Cached dfs-taint": {
      "main": [
        [
          {
            "node": "Merge Lines",
            "type": "main",
            "index": 4
          }
        ]
      ]
    },
    "Build Prompt dfs-taint": {
      "main": [
        [
          {
            "node": "Agent dfs-taint",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Agent dfs-taint": {
      "main": [
        [
          {
            "node": "Parse dfs-taint",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse dfs-taint": {
      "main": [
        [
          {
            "node": "Merge Lines",
            "type": "main",
            "index": 4
          },
          {
            "node": "Prepare Cache Value dfs-taint",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Cache Value dfs-taint": {
      "main": [
        [
          {
            "node": "Redis SET dfs-taint",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Lines": {
      "main": [
        [
          {
            "node": "Collect Normalize Dedup",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Collect Normalize Dedup": {
      "main": [
        [
          {
            "node": "Loop Findings",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Loop Findings": {
      "main": [
        [
          {
            "node": "Rate Limit",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Done",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Rate Limit": {
      "main": [
        [
          {
            "node": "Build Report Prompt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Report Prompt": {
      "main": [
        [
          {
            "node": "Reporter Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Reporter Agent": {
      "main": [
        [
          {
            "node": "Loop Findings",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "LLM": {
      "ai_languageModel": [
        [
          {
            "node": "Agent audit-fast",
            "type": "ai_languageModel",
            "index": 0
          },
          {
            "node": "Agent graph-lite",
            "type": "ai_languageModel",
            "index": 0
          },
          {
            "node": "Agent vul-rules",
            "type": "ai_languageModel",
            "index": 0
          },
          {
            "node": "Agent sca-leak",
            "type": "ai_languageModel",
            "index": 0
          },
          {
            "node": "Agent dfs-taint",
            "type": "ai_languageModel",
            "index": 0
          },
          {
            "node": "Reporter Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "MCP audit-fast": {
      "ai_tool": [
        [
          {
            "node": "Agent audit-fast",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "MCP graph-lite": {
      "ai_tool": [
        [
          {
            "node": "Agent graph-lite",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "MCP vul-rules": {
      "ai_tool": [
        [
          {
            "node": "Agent vul-rules",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "MCP sca-leak": {
      "ai_tool": [
        [
          {
            "node": "Agent sca-leak",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "MCP dfs-taint": {
      "ai_tool": [
        [
          {
            "node": "Agent dfs-taint",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "MCP report": {
      "ai_tool": [
        [
          {
            "node": "Reporter Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "8acd1db4-8a6e-4210-9790-e4f83a005817",
  "meta": {
    "instanceId": "REPLACE_WITH_YOUR_INSTANCE_ID"
  },
  "id": "REPLACE_WITH_YOUR_WORKFLOW_ID",
  "tags": [],
  "pinData": {}
}