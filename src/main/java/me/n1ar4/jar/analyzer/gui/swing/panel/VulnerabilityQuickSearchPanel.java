/*
 * GPLv3 License
 *
 * Copyright (c) 2022-2026 4ra1n (Jar Analyzer Team)
 *
 * This project is distributed under the GPLv3 license.
 *
 * https://github.com/jar-analyzer/jar-analyzer/blob/master/LICENSE
 */

package me.n1ar4.jar.analyzer.gui.swing.panel;

import me.n1ar4.jar.analyzer.engine.CoreEngine;
import me.n1ar4.jar.analyzer.engine.EngineContext;
import me.n1ar4.jar.analyzer.engine.SearchCondition;
import me.n1ar4.jar.analyzer.entity.MethodResult;
import me.n1ar4.jar.analyzer.gui.runtime.api.RuntimeFacades;
import me.n1ar4.jar.analyzer.gui.runtime.model.SearchResultDto;
import me.n1ar4.jar.analyzer.gui.swing.SwingI18n;
import me.n1ar4.jar.analyzer.rules.VulnerabilityRegistry;
import me.n1ar4.jar.analyzer.rules.vul.Rule;

import javax.swing.BorderFactory;
import javax.swing.ButtonGroup;
import javax.swing.JButton;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JRadioButton;
import javax.swing.SwingUtilities;
import javax.swing.border.TitledBorder;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.FlowLayout;
import java.awt.GridLayout;
import java.awt.Insets;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

final class VulnerabilityQuickSearchPanel extends JPanel {
    private static final int MAX_COLS = 3;
    private static final int BTN_H_GAP = 6;
    private static final int BTN_MIN_WIDTH = 124;
    private static final int BTN_PREF_WIDTH = 118;
    private static final int BTN_PREF_HEIGHT = 30;
    private static final int MIN_PANEL_HEIGHT = 220;
    private static final int MAX_PANEL_HEIGHT = 380;
    private static final int HEADER_ESTIMATE = 36;
    private static final int ROW_ESTIMATE = 42;
    private static final int PADDING_ESTIMATE = 12;

    private static final String FILTER_ALL = "all";
    private static final String FILTER_HIGH = "high";
    private static final String FILTER_MEDIUM = "medium";
    private static final String FILTER_LOW = "low";

    private final JRadioButton allRadio = new JRadioButton();
    private final JRadioButton highRadio = new JRadioButton();
    private final JRadioButton mediumRadio = new JRadioButton();
    private final JRadioButton lowRadio = new JRadioButton();

    private final JPanel presetHost = new JPanel(new BorderLayout());
    private final Map<String, List<VulPreset>> presetGroups = new HashMap<>();
    private final Map<String, JPanel> panelCache = new HashMap<>();
    private volatile String currentFilter = FILTER_ALL;

    VulnerabilityQuickSearchPanel() {
        super(new BorderLayout(4, 4));
        setPreferredSize(new Dimension(10, MIN_PANEL_HEIGHT));
        setMinimumSize(new Dimension(360, MIN_PANEL_HEIGHT));
        initUi();
        loadPresetsAsync();
    }

    private void initUi() {
        JPanel radioPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 8, 2));
        ButtonGroup group = new ButtonGroup();
        group.add(allRadio);
        group.add(highRadio);
        group.add(mediumRadio);
        group.add(lowRadio);
        allRadio.setSelected(true);
        radioPanel.add(allRadio);
        radioPanel.add(highRadio);
        radioPanel.add(mediumRadio);
        radioPanel.add(lowRadio);

        allRadio.addActionListener(e -> selectFilter(FILTER_ALL));
        highRadio.addActionListener(e -> selectFilter(FILTER_HIGH));
        mediumRadio.addActionListener(e -> selectFilter(FILTER_MEDIUM));
        lowRadio.addActionListener(e -> selectFilter(FILTER_LOW));

        presetHost.setBorder(BorderFactory.createEmptyBorder());
        presetHost.addComponentListener(new ComponentAdapter() {
            @Override
            public void componentResized(ComponentEvent e) {
                renderCurrentFilter();
            }
        });

        add(radioPanel, BorderLayout.NORTH);
        add(presetHost, BorderLayout.CENTER);
        applyLanguage();
    }

    void applyLanguage() {
        setBorder(BorderFactory.createTitledBorder(
                null,
                SwingI18n.tr("Java 漏洞", "Java Vulnerability"),
                TitledBorder.DEFAULT_JUSTIFICATION,
                TitledBorder.DEFAULT_POSITION,
                null,
                null
        ));
        allRadio.setText(SwingI18n.tr("全部", "all"));
        highRadio.setText(SwingI18n.tr("展示高危（high）", "high only"));
        mediumRadio.setText(SwingI18n.tr("展示中危（medium）", "medium only"));
        lowRadio.setText(SwingI18n.tr("展示低危（low）", "low only"));
    }

    private void selectFilter(String filter) {
        currentFilter = filter;
        renderCurrentFilter();
    }

    private void loadPresetsAsync() {
        Thread.ofVirtual().name("gui-vul-quick-load").start(() -> {
            Rule rule = VulnerabilityRegistry.getRule();
            Map<String, List<VulPreset>> groups = buildPresetGroups(rule);
            SwingUtilities.invokeLater(() -> {
                presetGroups.clear();
                presetGroups.putAll(groups);
                panelCache.clear();
                renderCurrentFilter();
            });
        });
    }

    private void renderCurrentFilter() {
        if (!SwingUtilities.isEventDispatchThread()) {
            SwingUtilities.invokeLater(this::renderCurrentFilter);
            return;
        }
        int columns = resolveColumns();
        String panelKey = currentFilter + "#" + columns;
        JPanel panel = panelCache.get(panelKey);
        if (panel == null) {
            panel = buildPresetPanel(presetGroups.get(currentFilter), columns);
            panelCache.put(panelKey, panel);
        }
        presetHost.removeAll();
        presetHost.add(panel, BorderLayout.CENTER);
        presetHost.revalidate();
        presetHost.repaint();
        int size = safeList(presetGroups.get(currentFilter)).size();
        adjustPreferredHeight(size, columns);
    }

    private JPanel buildPresetPanel(List<VulPreset> presets, int columns) {
        List<VulPreset> list = safeList(presets);
        if (list.isEmpty()) {
            JPanel empty = new JPanel(new BorderLayout());
            empty.add(new JLabel(SwingI18n.tr("无可用规则", "no available rules")), BorderLayout.CENTER);
            return empty;
        }
        JPanel grid = new JPanel(new GridLayout(0, Math.max(1, columns), BTN_H_GAP, 6));
        grid.setBorder(BorderFactory.createEmptyBorder(0, 0, 0, 0));
        for (VulPreset preset : list) {
            JButton button = new JButton(preset.name());
            button.setPreferredSize(new Dimension(BTN_PREF_WIDTH, BTN_PREF_HEIGHT));
            button.setMargin(new Insets(2, 8, 2, 8));
            button.setToolTipText(preset.name() + " [" + preset.level() + "]");
            paintByLevel(button, preset.level());
            button.addActionListener(e -> runQuickSearch(preset));
            grid.add(button);
        }
        JPanel wrapper = new JPanel(new BorderLayout());
        wrapper.add(grid, BorderLayout.NORTH);
        return wrapper;
    }

    private int resolveColumns() {
        int width = presetHost.getWidth();
        if (width <= 0) {
            width = getWidth();
        }
        if (width <= 0) {
            return MAX_COLS;
        }
        for (int col = MAX_COLS; col >= 1; col--) {
            int need = col * BTN_MIN_WIDTH + (col - 1) * BTN_H_GAP + 8;
            if (width >= need) {
                return col;
            }
        }
        return 1;
    }

    private void adjustPreferredHeight(int ruleCount, int columns) {
        int rows = Math.max(1, (ruleCount + Math.max(1, columns) - 1) / Math.max(1, columns));
        int targetHeight = HEADER_ESTIMATE
                + rows * ROW_ESTIMATE
                + PADDING_ESTIMATE;
        targetHeight = Math.max(MIN_PANEL_HEIGHT, Math.min(MAX_PANEL_HEIGHT, targetHeight));
        Dimension current = getPreferredSize();
        if (current == null || current.height != targetHeight) {
            setPreferredSize(new Dimension(10, targetHeight));
            setMinimumSize(new Dimension(360, targetHeight));
            revalidate();
        }
    }

    private void paintByLevel(JButton button, String level) {
        if (button == null) {
            return;
        }
        if (FILTER_HIGH.equals(level)) {
            button.setBackground(new Color(255, 204, 204));
            button.setOpaque(true);
            return;
        }
        if (FILTER_MEDIUM.equals(level)) {
            button.setBackground(new Color(204, 229, 255));
            button.setOpaque(true);
            return;
        }
        if (FILTER_LOW.equals(level)) {
            button.setBackground(new Color(242, 242, 242));
            button.setOpaque(true);
        }
    }

    private void runQuickSearch(VulPreset preset) {
        if (preset == null) {
            return;
        }
        Thread.ofVirtual().name("gui-vul-quick-search").start(() -> {
            CoreEngine engine = EngineContext.getEngine();
            if (engine == null || !engine.isEnabled()) {
                RuntimeFacades.search().publishExternalResults(
                        List.of(),
                        SwingI18n.tr("引擎尚未就绪", "engine is not ready")
                );
                return;
            }
            List<SearchResultDto> results = searchByPreset(engine, preset);
            String status = SwingI18n.tr("漏洞快速搜索", "vul quick search")
                    + " [" + preset.name() + "] "
                    + SwingI18n.tr("结果数: ", "results: ")
                    + results.size();
            RuntimeFacades.search().publishExternalResults(results, status);
        });
    }

    private List<SearchResultDto> searchByPreset(CoreEngine engine, VulPreset preset) {
        if (engine == null || preset == null || preset.conditions().isEmpty()) {
            return List.of();
        }
        Map<String, SearchResultDto> uniq = new LinkedHashMap<>();
        Set<String> queried = new LinkedHashSet<>();
        for (SearchCondition condition : preset.conditions()) {
            if (condition == null) {
                continue;
            }
            String className = normalizeValue(condition.getClassName());
            String methodName = normalizeValue(condition.getMethodName());
            String methodDesc = normalizeValue(condition.getMethodDesc());
            if (className == null || className.isBlank() || methodName == null || methodName.isBlank()) {
                continue;
            }
            String callKey = safe(className) + "#" + safe(methodName) + "#" + safe(methodDesc);
            if (!queried.add(callKey)) {
                continue;
            }
            List<MethodResult> methods = engine.getCallers(className, methodName, methodDesc);
            for (MethodResult m : methods) {
                if (m == null) {
                    continue;
                }
                String resultKey = safe(m.getClassName()) + "#" + safe(m.getMethodName())
                        + "#" + safe(m.getMethodDesc()) + "#" + m.getJarId();
                uniq.putIfAbsent(resultKey, toSearchResult(m, preset));
            }
        }
        return new ArrayList<>(uniq.values());
    }

    private SearchResultDto toSearchResult(MethodResult m, VulPreset preset) {
        String className = safe(m.getClassName());
        String methodName = safe(m.getMethodName());
        String methodDesc = safe(m.getMethodDesc());
        String preview = className + "#" + methodName + methodDesc
                + " [" + safe(preset.name()) + "/" + safe(preset.level()) + "]";
        return new SearchResultDto(
                className,
                methodName,
                methodDesc,
                safe(m.getJarName()),
                m.getJarId(),
                preview,
                "vul-" + safe(preset.level()),
                "unknown",
                "cls:" + normalizeClass(className) + "|" + m.getJarId()
        );
    }

    private Map<String, List<VulPreset>> buildPresetGroups(Rule rule) {
        Map<String, List<VulPreset>> groups = new HashMap<>();
        groups.put(FILTER_ALL, List.of());
        groups.put(FILTER_HIGH, List.of());
        groups.put(FILTER_MEDIUM, List.of());
        groups.put(FILTER_LOW, List.of());
        if (rule == null || rule.getLevels() == null || rule.getLevels().isEmpty()) {
            return groups;
        }
        Map<String, VulPresetAccumulator> allMap = new LinkedHashMap<>();
        Map<String, VulPresetAccumulator> highMap = new LinkedHashMap<>();
        Map<String, VulPresetAccumulator> mediumMap = new LinkedHashMap<>();
        Map<String, VulPresetAccumulator> lowMap = new LinkedHashMap<>();

        for (Map.Entry<String, Map<String, List<SearchCondition>>> levelEntry : rule.getLevels().entrySet()) {
            String level = normalizeLevel(levelEntry.getKey());
            Map<String, List<SearchCondition>> byType = levelEntry.getValue();
            if (byType == null || byType.isEmpty()) {
                continue;
            }
            for (Map.Entry<String, List<SearchCondition>> entry : byType.entrySet()) {
                String name = safe(entry.getKey()).trim();
                if (name.isEmpty()) {
                    continue;
                }
                List<SearchCondition> normalized = normalizeConditions(entry.getValue());
                if (normalized.isEmpty()) {
                    continue;
                }
                VulPresetAccumulator allAcc = allMap.computeIfAbsent(name, VulPresetAccumulator::new);
                allAcc.mergeLevel(level);
                allAcc.addConditions(normalized);

                Map<String, VulPresetAccumulator> levelMap = selectLevelMap(level, highMap, mediumMap, lowMap);
                VulPresetAccumulator levelAcc = levelMap.computeIfAbsent(name, VulPresetAccumulator::new);
                levelAcc.mergeLevel(level);
                levelAcc.addConditions(normalized);
            }
        }

        groups.put(FILTER_ALL, toPresetList(allMap));
        groups.put(FILTER_HIGH, toPresetList(highMap));
        groups.put(FILTER_MEDIUM, toPresetList(mediumMap));
        groups.put(FILTER_LOW, toPresetList(lowMap));
        return groups;
    }

    private Map<String, VulPresetAccumulator> selectLevelMap(String level,
                                                             Map<String, VulPresetAccumulator> highMap,
                                                             Map<String, VulPresetAccumulator> mediumMap,
                                                             Map<String, VulPresetAccumulator> lowMap) {
        if (FILTER_HIGH.equals(level)) {
            return highMap;
        }
        if (FILTER_LOW.equals(level)) {
            return lowMap;
        }
        return mediumMap;
    }

    private List<VulPreset> toPresetList(Map<String, VulPresetAccumulator> map) {
        if (map == null || map.isEmpty()) {
            return List.of();
        }
        List<VulPreset> out = new ArrayList<>();
        for (VulPresetAccumulator acc : map.values()) {
            if (acc == null || acc.conditions.isEmpty()) {
                continue;
            }
            out.add(new VulPreset(acc.name, acc.level, new ArrayList<>(acc.conditions)));
        }
        return out;
    }

    private List<SearchCondition> normalizeConditions(List<SearchCondition> conditions) {
        if (conditions == null || conditions.isEmpty()) {
            return List.of();
        }
        List<SearchCondition> out = new ArrayList<>();
        for (SearchCondition condition : conditions) {
            if (condition != null) {
                out.add(condition);
            }
        }
        return out;
    }

    private String normalizeLevel(String level) {
        String v = safe(level).trim().toLowerCase();
        if (FILTER_HIGH.equals(v) || FILTER_MEDIUM.equals(v) || FILTER_LOW.equals(v)) {
            return v;
        }
        return FILTER_MEDIUM;
    }

    private List<VulPreset> safeList(List<VulPreset> input) {
        return input == null ? Collections.emptyList() : input;
    }

    private String normalizeValue(String value) {
        String v = safe(value).trim();
        if (v.isEmpty() || "null".equalsIgnoreCase(v)) {
            return null;
        }
        return v.replace('.', '/');
    }

    private static String normalizeClass(String className) {
        String v = safe(className).trim();
        if (v.isEmpty()) {
            return "";
        }
        return v.replace('.', '/');
    }

    private static String safe(String value) {
        return value == null ? "" : value;
    }

    private static final class VulPresetAccumulator {
        private final String name;
        private String level = FILTER_LOW;
        private final List<SearchCondition> conditions = new ArrayList<>();

        private VulPresetAccumulator(String name) {
            this.name = name;
        }

        private void mergeLevel(String incoming) {
            if (levelRank(incoming) > levelRank(level)) {
                level = incoming;
            }
        }

        private void addConditions(List<SearchCondition> items) {
            if (items == null || items.isEmpty()) {
                return;
            }
            conditions.addAll(items);
        }

        private int levelRank(String level) {
            if (FILTER_HIGH.equals(level)) {
                return 3;
            }
            if (FILTER_MEDIUM.equals(level)) {
                return 2;
            }
            if (FILTER_LOW.equals(level)) {
                return 1;
            }
            return 0;
        }
    }

    private record VulPreset(String name, String level, List<SearchCondition> conditions) {
    }
}
